import ghidra.app.script.GhidraScript;
import ghidra.program.model.listing.*;
import ghidra.program.model.block.*;
import ghidra.program.model.address.*;
import ghidra.program.model.symbol.*;
import com.google.gson.*;

import java.io.*;
import java.util.*;

public class CFGJsonExporterScript extends GhidraScript {
	
	private static final Set<String> SYSTEM_FUNCTIONS = new HashSet<>(Arrays.asList(
        "malloc", "free", "tls_callback_1","mbstowcs", "exit","fesetenv", "strcpy", "memcpy", "memmove", "calloc", "realloc", "signal","setlocale","wcstombs"));
    @Override
    public void run() throws Exception {
        // --- 1. Find all functions in the program, skipping external and unneeded ones ---
        FunctionManager functionManager = currentProgram.getFunctionManager();
        FunctionIterator functions = functionManager.getFunctions(true); // true = forward iterator

        JsonArray allFunctionsJson = new JsonArray();
        Set<String> seenFunctions = new HashSet<>();  // Track seen functions to remove duplicates

        while (functions.hasNext()) {
            monitor.checkCanceled();
            Function function = functions.next();
            
            // Skip external functions (imported from shared libraries like libc)
            if (function.isExternal()) {
                continue;
            }
            
            // Apply filtering rules:
            String functionName = function.getName();
            if (isIrrelevantFunction(functionName) || seenFunctions.contains(functionName)) {  // Skip irrelevant or duplicate functions
                continue;
            }

            // Mark this function as seen to avoid duplicates
            seenFunctions.add(functionName);

            println("Processing function: " + function.getName() + " at " + function.getEntryPoint());
            
            // Export CFG for each relevant function
            JsonObject functionJson = exportFunctionCFG(function);
            allFunctionsJson.add(functionJson);
        }

        // --- 2. Write all functions' CFG to JSON ---
        JsonObject root = new JsonObject();
        root.add("functions", allFunctionsJson);

        // Path to the output JSON file
        String outputPath = "C:\\Users\\celin\\Desktop\\usj\\FYP\\agentic_obfuscator_deobfuscator_system\\obfuscation_deobfuscation_flow\\src\\obfuscation_deobfuscation_flow\\crews\\binaryobfuscationcrew\\ghidra_output\\functionInfo.json";
        try (FileWriter writer = new FileWriter(outputPath)) {
            writer.write(new GsonBuilder().setPrettyPrinting().create().toJson(root));
            println("Exported all relevant function CFGs to: " + outputPath);
        } catch (IOException e) {
            printerr("Failed to write JSON to file: " + e.getMessage());
        }
    }

    // --- Helper: Check if the function is irrelevant ---
    private boolean isIrrelevantFunction(String functionName) {
        // Skip external functions (imported from shared libraries like libc or Windows API)
        if (functionName.startsWith("_")) {
            return true;  // likely system or library functions (e.g., _malloc, _strdup)
        }

        // Skip functions with names starting with "FUN_" (likely autogenerated or irrelevant)
        if (functionName.startsWith("FUN_")) {
            return true;
        }

        // Skip functions named ".text" (often sections or labels, not actual functions)
        if (functionName.equals(".text")) {
            return true;
        }

	 // Skip library/system functions explicitly (e.g., malloc, free, etc.)
        if (SYSTEM_FUNCTIONS.contains(functionName)) {
            return true;
        }

        // Skip other system/library functions (those that are generally not part of C code)
        // (Examples of typical system functions to exclude can be expanded here)
        if (functionName.equals("atexit") || functionName.equals("abort")) {
            return true;
        }

        // Skip functions starting with "str" or "mem" (likely string or memory manipulation)
        if (functionName.startsWith("str") || functionName.startsWith("mem")) {
            return true;
        }

        // Include only functions with "meaningful" names (not compiler-generated names)
        if (functionName.length() < 3) {  // Filter out very short, likely meaningless function names
            return true;
        }

        return false;  // If none of the conditions match, the function is considered relevant
    }

    // --- Helper: Export CFG for a specific function ---
    private JsonObject exportFunctionCFG(Function function) throws Exception {
        JsonObject functionJson = new JsonObject();
        functionJson.addProperty("function", function.getName());
        JsonArray blocksArray = new JsonArray();

        BasicBlockModel bbModel = new BasicBlockModel(currentProgram);
        CodeBlockIterator blocks = bbModel.getCodeBlocksContaining(function.getBody(), monitor);

        while (blocks.hasNext()) {
            monitor.checkCanceled();
            CodeBlock block = blocks.next();
            Address start = block.getFirstStartAddress();
            Address end = block.getMaxAddress();

            JsonObject blockJson = new JsonObject();
            blockJson.addProperty("start", start.toString());
            blockJson.addProperty("end", end.toString());

            // Extract Instructions
            JsonArray instructions = new JsonArray();
            Instruction instr = getInstructionAt(start);
            while (instr != null && instr.getAddress().compareTo(end) <= 0) {
                String instrText = instr.getAddress().toString() + " " + instr.toString();
                instructions.add(instrText);
                instr = instr.getNext();
            }
            blockJson.add("instructions", instructions);

            // Extract Successors
            JsonArray successors = new JsonArray();
            CodeBlockReferenceIterator refs = block.getDestinations(monitor);
            while (refs.hasNext()) {
                CodeBlockReference ref = refs.next();
                successors.add(ref.getDestinationAddress().toString());
            }
            blockJson.add("successors", successors);

            // Determine Block Type (entry, conditional, normal)
            String type = "normal";
            if (start.equals(function.getEntryPoint())) {
                type = "entry";
            } else if (successors.size() > 1) {
                type = "conditional";
            }
            blockJson.addProperty("type", type);

            // Detect Function Calls in Block
            Set<String> calledFunctions = new HashSet<>();
            Instruction callInstr = getInstructionAt(start);
            while (callInstr != null && callInstr.getAddress().compareTo(end) <= 0) {
                if (callInstr.getMnemonicString().equalsIgnoreCase("CALL")) {
                    Address[] flows = callInstr.getFlows();
                    if (flows != null && flows.length > 0) {
                        Function called = getFunctionAt(flows[0]);
                        if (called != null) {
                            calledFunctions.add(called.getName());
                        } else {
                            calledFunctions.add(flows[0].toString());
                        }
                    }
                }
                callInstr = callInstr.getNext();
            }

            // Add called functions (if any) to the block JSON
            if (!calledFunctions.isEmpty()) {
                JsonArray calls = new JsonArray();
                callInstr = getInstructionAt(start);
                while (callInstr != null && callInstr.getAddress().compareTo(end) <= 0) {
                    if (callInstr.getMnemonicString().equalsIgnoreCase("CALL")) {
                        Address[] flows = callInstr.getFlows();
                        if (flows != null && flows.length > 0) {
                            Function called = getFunctionAt(flows[0]);
                            if (called != null) {
                                calls.add(flows[0].toString() + ": " + called.getName());
                            } else {
                                calls.add(flows[0].toString() + ": unknown");
                            }
                        }
                    }
                    callInstr = callInstr.getNext();
                }
                blockJson.add("calls", calls);
            }

            blocksArray.add(blockJson);  // Add the block JSON to the function's block array
        }

        functionJson.add("blocks", blocksArray);
        return functionJson;
    }
}
