# Ghidra Script Templates for Code Obfuscation Techniques
# These templates are meant to be populated by an LLM with real values
# such as addresses, instruction bytes, and labels.

# =============================
# 1. Opaque Predicate Insertion
# =============================
opaque_predicate_template = '''
# Technique: Opaque Predicate Insertion
# Target Function: ${function_name}
# Target Address: ${address}
# Description: Inserts a tautological condition that always evaluates to true.

from ghidra.program.model.mem import MemoryAccessException

def insert_opaque_predicate(addr_str):
    addr = toAddr(addr_str)

    try:
        clearListing(addr)

        # Fake opaque condition instructions (e.g., xor ecx, ecx; cmp ecx, 0; je ...)
        bytes_to_insert = ${instruction_bytes}  # e.g., b"\x31\xc9\x83\xf9\x00\x74\x05"

        insertBytes(addr, bytes_to_insert)

        createLabel(addr.add(${label_offset}), "opaque_true_branch", True)

    except MemoryAccessException as e:
        printerr("Memory access error at %s: %s" % (addr_str, str(e)))

insert_opaque_predicate("${address}")
'''

# =======================
# 2. Branch Inversion
# =======================
branch_inversion_template = '''
# Technique: Branch Inversion
# Target Function: ${function_name}
# Target Address: ${address}
# Description: Flip conditional jump and insert trampoline.

from ghidra.program.model.mem import MemoryAccessException

def insert_branch_inversion(addr_str):
    addr = toAddr(addr_str)

    try:
        clearListing(addr)

        bytes_to_insert = ${instruction_bytes}

        insertBytes(addr, bytes_to_insert)

        createLabel(addr.add(${label_offset_1}), "inversion_skip", True)
        createLabel(addr.add(${label_offset_2}), "equal_target", True)

    except MemoryAccessException as e:
        printerr("Memory access error: %s" % str(e))

insert_branch_inversion("${address}")
'''

# ============================
# 3. Dead Code Insertion
# ============================
dead_code_insertion_template = '''
# Technique: Dead Code Insertion
# Target Function: ${function_name}
# Target Address: ${address}
# Description: Insert junk instructions that do not affect program state.

from ghidra.program.model.mem import MemoryAccessException

def insert_dead_code(addr_str):
    addr = toAddr(addr_str)

    try:
        clearListing(addr)

        bytes_to_insert = ${instruction_bytes}  # e.g., b"\x31\xc9\x83\xc1\x01\x83\xe9\x01"

        insertBytes(addr, bytes_to_insert)

    except MemoryAccessException as e:
        printerr("Memory error: %s" % str(e))

insert_dead_code("${address}")
'''

# ================================
# 4. Instruction Substitution
# ================================
instruction_substitution_template = '''
# Technique: Instruction Substitution
# Target Function: ${function_name}
# Target Address: ${address}
# Description: Replace a single instruction with an equivalent instruction sequence.

from ghidra.program.model.mem import MemoryAccessException

def insert_instruction_substitution(addr_str):
    addr = toAddr(addr_str)

    try:
        clearListing(addr)
        bytes_to_insert = ${instruction_bytes}  # e.g., push + pop + xor + add + sub
        insertBytes(addr, bytes_to_insert)

    except MemoryAccessException as e:
        printerr("Substitution failed: %s" % str(e))

insert_instruction_substitution("${address}")
'''

# ============================
# 5. Control Flow Flattening
# ============================
control_flow_flattening_template = '''
# Technique: Control Flow Flattening
# Description: Replace structured control flow with a dispatcher loop.
# NOTE: This is a skeleton; requires full function rewrite.

from ghidra.program.model.mem import MemoryAccessException

def apply_flattening(start_addr_str):
    addr = toAddr(start_addr_str)

    # This is typically a full rewrite with jump table and state variable.
    # Example is symbolic; must be generated dynamically.
    bytes_to_insert = ${dispatcher_loop_bytes}

    try:
        clearListing(addr)
        insertBytes(addr, bytes_to_insert)
    except MemoryAccessException as e:
        printerr("Error applying flattening: %s" % str(e))

apply_flattening("${address}")
'''

# ================================
# 6. Arithmetic Branch Replacement
# ================================
arithmetic_branch_replacement_template = '''
# Technique: Arithmetic Branch Replacement
# Description: Replace branches with arithmetic setcc logic.

from ghidra.program.model.mem import MemoryAccessException

def insert_setcc_replacement(addr_str):
    addr = toAddr(addr_str)

    try:
        clearListing(addr)
        bytes_to_insert = ${instruction_bytes}  # e.g., cmp + setz
        insertBytes(addr, bytes_to_insert)
    except MemoryAccessException as e:
        printerr("SETcc insertion failed: %s" % str(e))

insert_setcc_replacement("${address}")
'''

# ===============================
# 7. Indirect Branch Conversion
# ===============================
indirect_branch_conversion_template = '''
# Technique: Indirect Branch Conversion
# Description: Replace direct jumps/calls with indirect versions.

from ghidra.program.model.mem import MemoryAccessException

def convert_to_indirect_branch(addr_str):
    addr = toAddr(addr_str)

    try:
        clearListing(addr)
        bytes_to_insert = ${instruction_bytes}  # mov reg, target; jmp reg
        insertBytes(addr, bytes_to_insert)
    except MemoryAccessException as e:
        printerr("Indirect jump failed: %s" % str(e))

convert_to_indirect_branch("${address}")
'''

# ================================
# 8. Constant Splitting/Encoding
# ================================
constant_splitting_template = '''
# Technique: Constant Splitting
# Description: Break large immediates into arithmetic steps.

from ghidra.program.model.mem import MemoryAccessException

def insert_constant_splitting(addr_str):
    addr = toAddr(addr_str)

    try:
        clearListing(addr)
        bytes_to_insert = ${instruction_bytes}  # e.g., mov + add
        insertBytes(addr, bytes_to_insert)
    except MemoryAccessException as e:
        printerr("Const split failed: %s" % str(e))

insert_constant_splitting("${address}")
'''

# ===============================
# 9. Unconditional Jump Chaining
# ===============================
unconditional_jump_chaining_template = '''
# Technique: Unconditional Jump Chaining
# Description: Replace jump with a chain of jumps.

from ghidra.program.model.mem import MemoryAccessException

def insert_jump_chain(addr_str):
    addr = toAddr(addr_str)

    try:
        clearListing(addr)
        bytes_to_insert = ${instruction_bytes}  # jmp a; a: jmp b
        insertBytes(addr, bytes_to_insert)
    except MemoryAccessException as e:
        printerr("Jump chain error: %s" % str(e))

insert_jump_chain("${address}")
'''

# ==============================
# 10. Function Call Obfuscation
# ==============================
function_call_obfuscation_template = '''
# Technique: Function Call Obfuscation
# Description: Use push+jmp instead of call.

from ghidra.program.model.mem import MemoryAccessException

def insert_fake_call(addr_str):
    addr = toAddr(addr_str)

    try:
        clearListing(addr)
        bytes_to_insert = ${instruction_bytes}  # push return; jmp func
        insertBytes(addr, bytes_to_insert)
    except MemoryAccessException as e:
        printerr("Call obfuscation failed: %s" % str(e))

insert_fake_call("${address}")
'''

# ===============================
# 11. Return Address Obfuscation
# ===============================
return_address_obfuscation_template = '''
# Technique: Return Address Obfuscation
# Description: Replace RET with pop + jmp.

from ghidra.program.model.mem import MemoryAccessException

def replace_ret(addr_str):
    addr = toAddr(addr_str)

    try:
        clearListing(addr)
        bytes_to_insert = ${instruction_bytes}  # pop reg; jmp reg
        insertBytes(addr, bytes_to_insert)
    except MemoryAccessException as e:
        printerr("Return obfuscation failed: %s" % str(e))

replace_ret("${address}")
'''
