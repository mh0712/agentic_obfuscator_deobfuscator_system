# =============================================================================================================================
# ----------------------------------------------------Binary Obfuscation Tasks-------------------------------------------------
# =============================================================================================================================
extraction_task:
  name: "Binary Feature Extraction"
  description: |
    Extract control flow, function-level details, and instruction-level data from the binary at {binary_path} using Ghidra scripts.
  expected_output: |
    {
      "functions": [
        {
          "name": "func_name",
          "blocks": [
            {
              "start": "0x...",
              "end": "0x...",
              "instructions": [...],
              "type": "entry|normal|exit",
              "successors": [...],
              "calls": [...]
            }
          ]
        }
      ]
    }
  agent: binary_analysis_agent

binary_technique_plan_task:
  name: "Obfuscation Planning"
  description: |
    Using  the extracted CFG and instruction-level data,
    Choose ALL the suitable obfuscation techniques from the provided knowledge base: {techniques}.
    Take all the present field values in the knowledge base fully into account not just part of them.
    Each selected technique must include:
    - technique_name
    - function_name 
    - description
    - reasoning
    - exampleOriginal: original code snippet
    - exampleObfuscated: obfuscated code snippet
    - implementationNotes: notes on how to implement the technique
    - ghidraSample: Ghidra code snippet for the technique
  expected_output: |
    [
      {
        "technique_name": "Control Flow Flattening",
        "description": "...",
        "reason": "Suitable for obfuscating multi-path logic...",
        "implementationNotes": [],
        "ghidraSample": {
          "javaMethod": "techniqueName",
          "code": []
        }
      }
    ]
  output_file: selected_techniques.json
  agent: binary_technique_planner_agent

plan_binary_obfuscation_patches:
  name: "Plan Binary Obfuscation Patch Locations"
  description: |

    # Task: Generate a Safe Patch Plan for Binary Obfuscation

    You are tasked with generating a valid and safe **patch plan** for applying **binary-level obfuscation** to a target executable.  
    This plan will later be used by another agent to generate an executable **Ghidra script** that modifies the binary.

    ---

    ## Ghidra Assembly Syntax Requirements (Read First)

    All assembly instructions **must** be written in syntax compatible with **Ghidra’s Sleigh assembler**:

    ### Rules
    - Do **NOT**  EVER use MASM or NASM-specific syntax such as:
      - `BYTE PTR`, `DWORD PTR`
      - `MOVABS`
      
    ### 2. Valid Registers for x86-32 (IA-32 Only)
    - **32-bit:** `EAX`, `EBX`, `ECX`, `EDX`, `ESI`, `EDI`, `EBP`, `ESP`
    - **16-bit:** `AX`, `BX`, `CX`, `DX`, `SI`, `DI`, `BP`, `SP`
    - **8-bit:** `AL`, `AH`, `BL`, `BH`, `CL`, `CH`, `DL`, `DH`
    -  **Do not use** any 64-bit registers like `RAX`, `RSI`, `RDI`.

    ### 3. Conditional Moves
    - Always use the full mnemonic: `cmovz`, `cmovnz`, etc.
    - Do not use aliases like `cmove`.

    ### 4. Instruction Byte Size Table

    ```json
    {
      "MOV": 3, "ADD": 3, "SUB": 3, "XOR": 3, "IMUL": 4, "CMP": 3,
      "TEST": 3, "JMP": 5, "JE": 5, "JZ": 5, "JA": 5, "JB": 5,
      "CALL": 5, "RET": 1, "NOP": 1, "HLT": 1, "WAIT": 1, "LOCK": 1,
      "PUSH": 2, "POP": 2, "AND": 3, "OR": 3, "NOT": 3, "SHL": 3,
      "SHR": 3, "SAR": 3, "ROL": 3, "ROR": 3,
      "MOVSB": 1, "MOVSW": 1, "MOVSD": 1, "MOVSQ": 1,
      "CMOVZ": 3, "CMOVNZ": 3, "CMOVA": 3, "CMOVAE": 3,
      "CMOVB": 3, "CMOVBE": 3, "CMOVG": 3, "CMOVGE": 3,
      "CMOVL": 3, "CMOVLE": 3, "CMOVS": 3, "CMOVNS": 3
    }
    ```
     Inputs

      You are provided with the following files:

      Binary path: {binary_path}

      Free memory regions:

      free_memory_ge12.json — regions ≥ 12 bytes (for Dead Code Insertion)

      free_memory_lt12.json — regions < 12 bytes (for Arithmetic Branch Replacement)

      Conditional branches:

      conditional_branches.json — all conditional branches in the binary (Choose the branch with JZ or JNZ as the Jump instruction)

      Selected techniques:

      selected_techniques.json — descriptions and constraints of selected obfuscation methods

     **Requirements & Constraints**

      1. Instruction Safety

      Use only allowed registers listed above.

      Do not use 64-bit registers or invalid syntax.

      2. Memory Safety

      Patches must target only free memory.

      Do not overwrite live code unless verified safe.

      3. Follow Techniques Precisely

      Techniques must match what’s described in selected_techniques.json.

      4. Byte-Level Precision

      Instruction sizes must exactly match the available bytes.

      Group instructions only if their combined size fits the region.

      5. Address Validity

      Before using any address, call toAddr() and check for null.

      Skip the patch or label if the address is invalid.

    **Note: Use "NZ" instead of "NE" — Ghidra does not support NE.

      Layered Obfuscation

      Each patch must include a "layer" field:

      0 = Apply first

      1 = Apply after layer 0

      2, 3, etc.

      **Final Notes**

      This patch plan will be used to generate real binary patches, so it must be:

      Accurate

      Size-matched

      Safe

      Valid JSON

      Any invalid field, instruction, or structure can corrupt the binary.

  expected_output: |
    A JSON array where each object contains:
      - "type": obfuscation technique name
      - "addresses": insert/replace info, including exact VA and instructions
      - "operands": all used registers, constants, and label targets
      - "layer": obfuscation layer index (order)
      {
        "type": "junk insertion",
        "addresses": {
          "insert": [
            {
              "address": "0x00408024",
              "instructions": [
                "XOR EAX, EAX",
                "ADD EAX, 10h"
              ]
            }
          ],
          "replace": [
            {
              "address": "0x00408030",
              "instruction": "je 0x00408100",
              "replacement": [
                "CMP EAX, 0h",
                "JZ 0x00408100"
              ]
            }
          ]
        },
        "operands": {
          "registers": ["EAX"],
          "constants": [0, 16],
          "labels": ["0x00408100"]
        },
        "layer": 0
      }

  agent: binary_patch_planner_agent
  output_file: patch_locations.json


apply_obfuscations_task:
  name: "Generate Ghidra Patch Script"
  description: |
    Generate a Java-based Ghidra script named **ApplyObfuscationTechniques.java** (with a public class `ApplyObfuscationTechniques` extending `GhidraScript`) that applies multiple binary-level obfuscation techniques using the Ghidra scripting API. The obfuscation steps must follow the patching instructions defined in a plan provided by `plan_binary_obfuscation_patches`. The output must be only the complete source code—no comments, no explanations. no brackets or ```java before and after the code.

    **High-Level Requirements**  
    - A single public class named `ApplyObfuscationTechniques extends GhidraScript`.  
    - Script must apply binary patches based on the patch plan from `plan_binary_obfuscation_patches`.  
    - No GUI or user input.
    - The instrunction should be compatible with Ghidra's Sleigh assembler with 32-bit architecture.

    **Setup in `run()`**  
    1. Declare a class-level field:  
      ```java
      private Assembler asm;
      ```  
    2. Inside `run()`, initialize it once:  
      ```java
      asm = Assemblers.getAssembler(currentProgram);
      ```  

    **Obfuscation Methods**  
    - Implement each obfuscation technique from the plan in its own `private void` method  
    - if you need to use a patchInstructions function, write it this way:
    **Helper Method**  
    ```java
    private void patchInstructions(String address, String[] instructions) throws Exception {
        Address addr = toAddr(address);
        Listing listing = currentProgram.getListing();
        for (String instruction : instructions) {
            asm.assemble(addr, instruction);
            Instruction inserted = listing.getInstructionAt(addr);
            if (inserted == null) {
                printerr("Failed to fetch instruction at: " + addr);
                break;
            }
            println("Patched at " + addr + ": " + instruction);
            addr = addr.add(inserted.getLength());
        }
    }
    ```  

    **Label Usage**  
    - Do not use label syntax in the instruction strings. To define a label, use:  
      ```java
      createLabel(toAddr("0x140001600"), "dispatcher_label", true);
      ```  

      **Note**: Conditional move instructions (`CMOVcc`) must always include their condition suffix (e.g., `CMOVZ`, `CMOVNZ`). Plain `CMOVE` is **not valid syntax** in Ghidra's Sleigh assembler.


    **Allowed Imports Only**  
    import ghidra.app.script.GhidraScript;
    import ghidra.app.plugin.assembler.*;
    import ghidra.program.model.address.*;
    import ghidra.util.exception.*;
    import ghidra.program.model.listing.*;

    **Final Output**  
    Output only the complete, executable Java class source code for `ApplyObfuscationTechniques.java`, including:  
    - The `run()` method calling each obfuscation technique method.  
    - Each obfuscation technique in its own `private void` method.  
    - The `patchInstructions(...)` helper (Optional)
    - No surrounding explanation or markdown—just the Java source.
    - No comments, no explanations, no brackets or ```java before and after the code.
    - No extra lines or spaces.
    

  expected_output: |
    The script must be a fully functional and directly executable Ghidra Java script named `ApplyObfuscationTechniques.java`. The output must include only the **entire source code**, formatted as a complete Java class—no explanations, comments, or diagnostic output:
    
    import ghidra.app.script.GhidraScript;
    import ghidra.app.plugin.assembler.*;
    import ghidra.program.model.address.*;
    import ghidra.util.exception.*;
    import ghidra.program.model.listing.*;
    import ghidra.util.exception.*;
    import ghidra.program.model.listing.*;

    private class ApplyObfuscationTechniques extends GhidraScript {
        private Assembler asm;

        @Override
        public void run() throws Exception {
            asm = Assemblers.getAssembler(currentProgram);
           .......
            ``` add your obfuscation techniques here ```
            .......
        }

        private void insertDeadCode() throws Exception {
            .....
        }

        .......
    }

  agent: ghidra_patch_agent
  output_file: /src/obfuscation_deobfuscation_flow/crews/binaryobfuscationcrew/ghidra_scripts/ApplyObfuscationTechniques.java


ghidra_script_runner_task:
  name: "Run Ghidra Patch Script"
  description: |
    Execute the Ghidra script **ApplyObfuscationTechniques.java** to apply the obfuscation techniques to the binary at `{binary_path}`. The script must be run in a Ghidra environment with the current program set to the target binary.

    **Requirements**:
    - Use the Ghidra API to run the script.
    - Ensure that the script runs without user interaction.
    - Handle any exceptions that may occur during script execution.

  expected_output: |
    The output should confirm successful execution of the Ghidra script, including any errors or warnings encountered during the process.

  agent: ghidra_script_runner_agent