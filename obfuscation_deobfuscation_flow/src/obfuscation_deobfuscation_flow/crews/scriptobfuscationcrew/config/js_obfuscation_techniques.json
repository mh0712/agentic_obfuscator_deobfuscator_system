{
  "obfuscation_techniques": [
    {
      "name": "Variable Renaming",
      "transformation_type": "structure",
      "layering_priority": 6,
      "conflicts_with": [],
      "applicability": ["python", "javascript"],
      "conditions": {
        "min_identifiers": 3
      },
      "complexity_rating": 3,
      "description": "Replace variable and function names with randomly generated strings to hinder readability and reverse engineering.",
      "llm_prompt": {
        "task": "Apply Variable Renaming obfuscation to the given source code.",
        "steps": [
          "1. Identify all variables in the source code, including local variables, global variables, parameters, functions, classes, methods and constants.",
          "2. Rename each variable with a unique, non-descriptive name. The new names should be short, random, and lack any meaningful relationship to the original names (e.g., `a`, `b`, `x1`, `temp123`).",
          "3. Ensure that the renamed variables do not conflict with other existing variables or reserved keywords in the language.",
          "4. Replace every instance of the original variable with its new name throughout the entire code base.",
          "5. Optionally, droduce some misleading names to confuse reverse engineers (e.g., naming variables with names that seem meaningful but aren’t).",
          "6. If the variables are used across multiple files, ensure the renaming is consistent across all affected files.",
          "7. Ensure that the renamed variables retain their original behavior, and the program logic remains dact.",
          "8. Avoid any pattern or recognizable structure in the naming convention to make it harder to predict or reverse-engineer the program."
        ],
        "example": [
          {
            "before": [
              "let total = 0;",
              "for (let i = 0; i < 10; i++) {",
              "    total += i;",
              "}",

              "return total;"
            ],
            "after": [
              "let x1 = 0;",
              "for (let y1 = 0; y1 < 10; y1++) {",
              "    x1 += y1;",
              "}",

              "return x1;"
            ]
          }
        ]
      }
    },
    {
      "name": "Opaque Predicates",
      "transformation_type": "control-flow",
      "layering_priority": 2,
      "conflicts_with": ["Dead Code Injection"],
      "applicability": ["python", "javascript"],
      "conditions": {
        "min_control_structures": 1
      },
      "complexity_rating": 6,
      "description": "droduce opaque predicates that evaluate to always true or false but appear complex, making the control flow harder to analyze.",
      "llm_prompt": {
        "task": "Apply Opaque Predicates obfuscation to the given source code.",
        "steps": [
          "1. Identify all conditional statements in the code (e.g., if, while, for, switch).",
          "2. Insert an opaque predicate inside these conditionals, which is a complex, seemingly true or false expression that always evaluates to a constant value (e.g., 'true' or 'false') but looks complex to understand.",
          "3. The opaque predicate should involve operations that make it hard to predict its outcome, such as mathematical operations, function calls, or logical operations.",
          "4. Ensure the condition still behaves as expected while adding the opaque predicate.",
          "5. Replace simple conditional checks with opaque predicates that will always resolve to true or false, making it harder for reverse engineers to predict the program's behavior.",
          "6. Avoid making the program logic change, so the obfuscation should not alter the final result but complicate the flow for analysis.",
          "7. Use `if (complex_expression)` or `while (complex_expression)` patterns where `complex_expression` is the opaque predicate."
        ],
        "example": {
          "before": "if (x === 5) { doSomething(); }",
          "after": [
            "let opaque_condition = (x * x + 3 * x + 2) % 2 === 0;",
            "if (opaque_condition) {",
            "    doSomething();",
            "}"
          ]
        }
      }
    },
    {
      "name": "Dead Code Injection",
      "transformation_type": "structure",
      "layering_priority": 4,
      "conflicts_with": ["Opaque Predicates"],
      "applicability": ["python", "javascript"],
      "conditions": {
        "min_code_blocks": 2
      },
      "complexity_rating": 4,
      "description": "Inject non-functional code blocks that don't affect runtime behavior to mislead code readers and analysis tools.",
      "llm_prompt": {
        "task": "Apply Dead Code Injection obfuscation to the given source code.",
        "steps": [
          "1. Identify regions in the code where extra logic can be added without altering the program's behavior.",
          "2. Insert code that performs meaningless operations, such as unnecessary calculations, assignments, or function calls.",
          "3. Ensure the inserted code does not affect the overall program logic, and it should not be executed during normal runtime (e.g., by using unreachable code or conditions that always evaluate to false).",
          "4. Insert conditional statements that will always fail, like 'if (false)', or dead loops that don’t affect program flow.",
          "5. Use computations or logic that does not impact any output or final result, such as variables that are calculated but never used, or functions that are called but never return any meaningful result.",
          "6. The dead code should be convoluted enough to confuse reverse engineers and make it difficult to distinguish from functional code.",
          "7. Do not leave any noticeable traces that would indicate to the reverse engineer that the code is dentionally injected as dead code."
        ],
        "example": {
          "before": ["let sum = a + b;", "return sum;"],
          "after": [
            "let unused_var1 = a * 2 + b / 3;",
            "let unused_var2 = a + b - 10;",
            "let sum = a + b;",
            "if (false) { let dead_code = sum * 1000; }",
            "return sum;"
          ]
        }
      }
    },
    {
      "name": "Control Flow Insertion",
      "transformation_type": "control-flow",
      "layering_priority": 3,
      "conflicts_with": [],
      "applicability": ["python", "javascript"],
      "conditions": {
        "min_control_flow_structures": 1
      },
      "complexity_rating": 7,
      "description": "Insert extra control flow statements, like loops, conditionals, and switches, to make the logic of the program harder to follow.",
      "llm_prompt": {
        "task": "Apply Control Flow Insertion obfuscation to the given source code.",
        "steps": [
          "1. Identify key decision pods and control structures in the code, such as conditional statements (if-else, switch), loops (for, while), and function calls.",
          "2. Insert additional control flow structures (e.g., fake conditionals, loops, or function calls) that do not alter the program's overall behavior but make the flow of execution more complex.",
          "3. Ensure that these inserted control flows are not executed under normal conditions. Use conditions that are always true or always false (e.g., if (false), if (true)), or insert loops that terminate immediately.",
          "4. Make sure the inserted control flow structures do not alter any important data or logic, they should serve only to confuse reverse engineering efforts.",
          "5. Add irrelevant function calls or operations that do not affect the program’s output but are computationally expensive or complex enough to mislead analysis.",
          "6. Use dynamic constructs where possible, such as functions or methods that generate new code paths at runtime.",
          "7. Obfuscate the purpose of the control flow structures so they appear as though they might impact program logic, while actually serving no purpose.",
          "8. Ensure that the program's original functionality is preserved and behaves the same after the obfuscation."
        ],
        "example": {
          "before": "if (x > 5) { doSomething(); } else { doNothing(); }",
          "after": [
            "if (true) {",
            "    let temp = 10;",
            "    if (false) { temp = 20; }",
            "    // Fake logic for obfuscation",
            "}",
            "if (x > 5) {",
            "    doSomething();",
            "} else {",
            "    doNothing();",
            "}",
            "if (false) {",
            "    let dummy = 0;",
            "    dummy += 1;",
            "}"
          ]
        }
      }
    },
    {
      "name": "Identifier Aliasing",
      "transformation_type": "structure",
      "layering_priority": 5,
      "conflicts_with": [],
      "applicability": ["python", "javascript"],
      "conditions": {
        "min_identifiers": 3
      },
      "complexity_rating": 4,
      "description": "Create aliases for standard or user-defined identifiers by assigning them to randomly named variables or functions, to obscure their actual purpose.",
      "llm_prompt": {
        "task": "Apply Identifier Aliasing obfuscation to the given source code.",
        "steps": [
          "1. Identify key variables, constants, or function names in the code that are critical to its logic.",
          "2. Create aliases for these identifiers by droducing new names (e.g., `tempVar`, `hiddenFunc`) that still map to the original identifier.",
          "3. Replace all occurrences of the original identifier with its alias throughout the code.",
          "4. Ensure that the alias is used consistently and that the original name is no longer directly visible in the code.",
          "5. Avoid making the aliases too predictable (e.g., using random or misleading names like `alpha`, `bravo`, etc.) to make it harder to trace the original variable or function names.",
          "6. If necessary, group multiple aliases for related identifiers (e.g., multiple variables or functions) under a common name or structure.",
          "7. Ensure the program behaves exactly as before, with no functional changes or side effects caused by the aliasing.",
          "8. Optionally, you can further obfuscate by creating additional mappings between original names and their aliases using a lookup table or array."
        ],
        "example": {
          "before": "let sum = a + b; let result = sum * 2; return result;",
          "after": [
            "let alpha = a + b;",
            "let bravo = alpha * 2;",
            "return bravo;"
          ]
        }
      }
    },
    {
      "name": "Minification",
      "transformation_type": "structure",
      "layering_priority": 10,
      "applicability": ["javascript"],
      "conditions": {
        "min_code_length": 20
      },
      "complexity_rating": 2,
      "description": "Reduce the size of the code by removing unnecessary whitespace, comments, and renaming variables to shorter names.",
      "llm_prompt": {
        "task": "Apply Minification obfuscation to the given source code.",
        "steps": [
          "1. Identify all variable names, function names, and class names in the code.",
          "2. Shorten variable, function, and class names to the smallest possible size. Use a single character or a short combination of letters (e.g., `a`, `b`, `x1`, `fn1`, etc.).",
          "3. Remove unnecessary whitespace, including spaces, tabs, and newlines, to reduce the size of the code.",
          "4. Remove all comments from the code to further reduce size and make the code harder to understand.",
          "5. Inline variables where possible, replacing variable assignments with direct values or expressions.",
          "6. Ensure that all code remains functional after minification, with no logic or behavior changes.",
          "7. Optionally, compress strings by replacing them with shorter values or encoding them if allowed.",
          "8. Ensure that no readable or easily traceable patterns remain, making it hard for a reverse engineer to comprehend the code."
        ],
        "example": {
          "before": "function calculateTotal(a, b) {\n  // Calculate the total sum\n  let total = a + b;\n  return total;\n}",
          "after": "function f(a, b) { return a + b; }"
        }
      }
    }
  ]
}
