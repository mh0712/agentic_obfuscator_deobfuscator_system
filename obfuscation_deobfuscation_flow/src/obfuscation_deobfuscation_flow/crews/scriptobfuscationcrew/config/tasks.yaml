# =============================================================================================================================
# ----------------------------------------------------Script Obfuscation Tasks-------------------------------------------------
# =============================================================================================================================

technique_selection_task:
  description: |
    Reasoning: Given the source code's complexity metrics, programming language, and a list of available obfuscation techniques, we must reason about compatibility, suitability, and diversity of techniques.

    Action Plan:
    1. Filter techniques by 'applicability' to ensure they support the target programming language. [Ref: technique schema]
    2. Evaluate complexity metrics (e.g., number of variables, functions) and match them with each techniqueâ€™s 'conditions'. [Ref: complexity-based selection logic]
    3. Strictly enforce any hard preconditions (min/max thresholds, required fields). [Ref: constraints enforcement]
    4. Detect and resolve conflicts using 'conflicts_with'; retain the more structurally relevant technique. [Ref: conflict resolution strategy]
    5. Ensure diversity across categories: control-flow, data, and structural techniques. [Ref: obfuscation taxonomy]
    6. Sort remaining techniques by their `layering_priority`, from lowest to highest. [Ref: ordering mechanism]
    7. Return selected techniques with their complete `llm_prompt` and `layering_priority`.

    Inputs:
      - code complexity metrics: {complexity}
      - available techniques: {techniques}
      - programming language: {language}

  expected_output: |
    [
      {
        "llm_prompt": {
          "task": "...",
          "steps": [...],
          "example": {
            "before": "...",
            "after": "..."
          }
        },
        "layering_priority": number
      }
    ]
  agent: technique_selector
  output_file: tests/selected_techniques.json

code_obfuscation_task:
  description: |
    Reasoning: Apply selected obfuscation techniques in the right order to transform the code without affecting its functionality.

    Action Plan:
    1. Order techniques by `layering_priority` ascending. [Ref: layering strategy]
    2. For each technique:
       - Read `llm_prompt` with its task, steps, and example. [Ref: llm_prompt format]
       - Apply transformations one at a time.
       - Validate syntax after every step. [Ref: code transformation safety]
       - Do not apply a technique if it risks altering the original behavior. [Ref: functional integrity]
    3. Skip techniques that are language-incompatible. [Ref: applicability check]
    4. Ensure output code is syntactically valid, executable, and functionally equivalent.
    5. Remove all explanatory text, comments, or markdown (e.g., no code fences).
    6. Return the final obfuscated code.

    Input:
      - Original source code
      - Selected techniques

    Output must be:
      - Obfuscated
      - Functionally identical
      - Syntactically valid
      - Devoid of comments or explanations

  expected_output: |
    <code>
    </code>
  agent: obfuscation_llm
  output_file: tests/obfuscated_code.{extension}

string_encryptor_task:
  description: |
    Reasoning: Finalize the obfuscation by targeting string literals and print statements for encryption using an external tool.

    Action Plan:
    1. Receive the obfuscated code from the previous task. [Ref: task dependency]
    2. Pass it into the encryption_tool which extracts and encrypts all string literals.
    3. Substitute encrypted strings back into the original code locations. [Ref: transformation rule]
    4. Return fully obfuscated code with proper formatting and no comments or annotations.
    5. Ensure final code is executable, syntax-valid, and complete.

    Constraints:
    - Output must be the entire obfuscated source code.
    - No code fences, no explanations, no formatting hints.
    - Code must be valid and indentation-preserved.
    - File must execute without syntax or runtime errors.

  expected_output: |
    <code>
    </code>
  agent: string_encryptor_agent
  output_file: tests/obfuscation.{extension}




# apply_packing_protection:
#   description: |
#     Finalize the obfuscation process by applying advanced techniques to the corrected obfuscated code.
#     This includes:
#     1. **AES Encryption**: Encrypt the code using AES encryption to protect it from reverse engineering.
#     2. **Compression**: Compress the encrypted code to reduce its size and make it less recognizable.
#     3. **Bytecode Transformation**: Convert the code into bytecode to further obscure its logic and structure.
#     4. **Self-Executing Loader**: Create a self-executing loader that decrypts and executes the obfuscated code at runtime.
#     5. **Standalone File**: Ensure the final output is a standalone Python file that can be executed without any dependencies.

#     use the packer_tool tool to apply these techniques to the corrected obfuscated code.
#     The tool will parse the code, apply AES encryption, compress the code, transform it into bytecode, and create a self-executing loader.
#     You should give the packer_tool the obfuscated code from the string_encryptor_task as input and the language {language} as the language.
#     The process should be seamless and should not require any additional libraries or dependencies to run.
#     Before returning the final output, ensure that the code is still syntactically correct and executes without errors.
#     The final output should be a single file that contains the obfuscated code, the AES encryption key, and the self-executing loader.
#     Do not execute the code, just return the final output as a string.
#     Input:
#     - Obfuscated code from the string_encryptor_task
#     - Language: {language}

#   expected_output: |
    
#       dr2tt4j7i4 = b'\xfb\xa6\x10\x92\xe5Q.w\xbbJ/\xc9\xc9\x15\x17Q'
#       hm69jggwyb = b'"\x89L\xfb&=A\xba\xe7\x96\xb4\xa9MX\xfe\xd6'

#       def bid5s_axmd():
#           from Crypto.Cipher import AES
#           from Crypto.Util.Padding import unpad
#           import base64
#           def ffe528k2jr(enc_str):
#               cipher = AES.new(dr2tt4j7i4, AES.MODE_CBC, hm69jggwyb)
#               return unpad(cipher.decrypt(base64.b85decode(enc_str)), 16).decode()
#           return ffe528k2jr
#       mj81e7yntf = bid5s_axmd()

#       nf3lp6r2zr = __import__(mj81e7yntf('6aGfP8g`|pB&PLLSupWR'))
#       mp2d8zv_jv = __import__(mj81e7yntf('9-qvWv3WKC8Z<%E;nX4T'))
#       p0tmnaoppd = __import__(mj81e7yntf('BpC?3fQ4A&%(qqEVS#ei'))
#       dcgn05ed4q = __import__(mj81e7yntf('`$r~dPXtyWb7gbcesDwv'))
#       r8onku4vrq = __import__(mj81e7yntf('t^IiFsw1~{Y;$9W*Ma`l'))
#       udd3w3yylz = __import__(mj81e7yntf('d;OuACsMx)zX(HbG9~$^'))
#       h7qeo5bvin = __import__(mj81e7yntf('?y(GS_QXRX==~I|SNF#N'))

#       _temp_crypto = __import__(mj81e7yntf('<5GWcTOC$JkdIVn4^_*k'))
#       wwv5s061yh = getattr(_temp_crypto.Cipher, mj81e7yntf('fsiv<jPX{;PqFsuIVA6t'))
#       _temp_crypto_util = __import__(mj81e7yntf('<5GWcTOC$JkdIVn4^_*k'))
#       c4c9i56x6q = getattr(_temp_crypto_util.Util.Padding, mj81e7yntf('CIs<<o-9G}2!g+OciE&t'))

#       def rslwzbdthe():
#           # Decrypt the function call to `windll.kernel32.IsDebuggerPresent()` dynamically at runtime
#           debugger_check_str = mj81e7yntf('isQAMt^)hYo;$!^)K(;V$3u~0h3#FPAn0W;-9AyJZERPkIgcdJN>~=rRg;{b')
#           windll = __import__(mj81e7yntf('&g1hE68jf?L`!Gy3lh8b')).windll
#           kernel32 = windll.kernel32
#           IsDebuggerPresent = getattr(kernel32, mj81e7yntf('_w^z0@XL)ca>CyFySInDCCvlg(4t(Vagm3*)83A3'))
#           if nf3lp6r2zr.gettrace() or (mp2d8zv_jv.name == mj81e7yntf('7a|xO&wDvQlF4SNy-90j') and IsDebuggerPresent()):
#               nf3lp6r2zr.exit(1)
#       rslwzbdthe()

#       def ng9g6vml5c(data):
#           try:
#               cipher = wwv5s061yh.new(dr2tt4j7i4, wwv5s061yh.MODE_CBC, hm69jggwyb)
#               return c4c9i56x6q(cipher.decrypt(data), 16).decode()
#           except:
#               return mj81e7yntf('I+7eR?vvFyV-<1A0bIZ4')

#       def w3yix3_nib():
#           try:
#               _encrypted = <encrypted_code>
#               cipher = wwv5s061yh.new(dr2tt4j7i4, wwv5s061yh.MODE_CBC, hm69jggwyb)
#               decoded = p0tmnaoppd.b85decode(_encrypted)
#               decrypted = c4c9i56x6q(cipher.decrypt(decoded), 16)
#               decompressed = udd3w3yylz.decompress(decrypted)
#               exec(r8onku4vrq.loads(decompressed), {
#                   **globals(),
#                   mj81e7yntf('4L^gRkcEBU1wqQM((+!v'): mj81e7yntf('nSAQL`i(g1ts%g(o8Fuu'),
#                   mj81e7yntf('%!Hy$YR{OC!+w-22CPDU'): __builtins__,
#                   mj81e7yntf('i2m<`)UaH6A4cqvM5Y&='): ng9g6vml5c
#               })
#           except Exception:
#               getattr(__builtins__, mj81e7yntf('gkJWyk9g2ll5mkfDtH<X'))(mj81e7yntf('cC06AT=Zy*$Q}1v-7K&Z&sF<VDl894{HKoMnl#;y'))
#               h7qeo5bvin.print_exc()
#               nf3lp6r2zr.exit(1)

#       if globals().get(mj81e7yntf('4L^gRkcEBU1wqQM((+!v')) == mj81e7yntf('nSAQL`i(g1ts%g(o8Fuu'):
#           w3yix3_nib()

#   agent: packer_agent
#   output_file: tests/final_obfuscated_code.{extension}
