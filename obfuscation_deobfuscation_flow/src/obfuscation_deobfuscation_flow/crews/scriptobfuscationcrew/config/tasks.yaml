# =============================================================================================================================
# ----------------------------------------------------Script Obfuscation Tasks-------------------------------------------------
# =============================================================================================================================

technique_selection_task:
  description: |
    Evaluate and select suitable obfuscation techniques for the given source code based on its complexity metrics and the available technique definitions.

    Follow these steps:
    1. **Language Compatibility**: Filter techniques that match the target programming language as defined in their 'applicability' field.
    2. **Complexity Suitability**: Match techniques whose 'conditions' are satisfied by the given `complexity` metrics (e.g., number of variables, functions).
    3. **Precondition Check**: Enforce hard limits or required metrics in each technique's 'conditions' field.
    4. **Conflict Resolution**: If techniques conflict (see 'conflicts_with'), prefer the one more aligned with the code structure.
    5. **Diversity of Techniques**: Prioritize a mix of data, control-flow, and structural obfuscation types.
    6. **Layering Priority**: Sort selected techniques by their `layering_priority` (low to high).
    7. For each chosen technique, return the `layering_priority` and its full `llm_prompt`.

    Inputs:
      - code complexity metrics: {complexity}
      - available techniques: {techniques}
      - programming language: {language}

  expected_output: |
    [
      {
        "llm_prompt": {
          "task": "...",
          "steps": [...],
          "example": {
            "before": "...",
            "after": "..."
          }
        },
        "layering_priority": number
      }
    ]
  output_file: tests/selected_techniques.json
  agent: technique_selector


code_obfuscation_task:
  description: |
    Obfuscate the provided source code using the selected techniques by the technique_selection_task in order of their layering_priority.

    Steps:
    1. Sort selected techniques from lowest to highest `layering_priority`.
    2. For each technique:
       - Read the `llm_prompt` including `task`, `steps`, and `example`.
       - Apply the transformation to the code incrementally.
       - Validate code syntax after each step.
       - Never apply a technique at all if you are not 100% sure that your output gives things and runs the exact same as the original code.
    3. Skip techniques incompatible with the language.
    5. Ensure the final output is syntactically valid, executable, and preserves functionality.
    6. Ensure the output is a pure obfuscated code without any comments, text or explanations before or after the code block.
    7. After applying all techniques, ensure the output is functionally identical to the original code without any syntax errors.

    Input:
      - Original source code
      - Selected techniques

    Output must be:
      - Obfuscated
      - Functionally identical to the original
      - Resistant to static analysis
      - Without any syntax errors

    Output Must contain:
      - Only the obfuscated code, no comments or explanations.
      - No extra text or formatting (e.g., no "```python" or "```javascript").
      - No quotes or backticks around the full code.

  expected_output: |
    <code>
    </code>
  agent: obfuscation_llm
  output_file: tests/obfuscated_code.{extension}

string_encryptor_task:
  description: |
    Input the code given by the code_obfuscation_task into the encryption_tool. The tool will parse the code, extract lines with print statements and string literals, and return a fully obfuscated version of the source code.

     Output Must contain
      - The entire obfuscated source code, with all substitutions applied.
      - Only the obfuscated code, no comments or explanations.
      - No extra formatting (e.g., no code fences or quote blocks).
      - The obfuscated code must be written to the output file specified below.
      - The process must ensure that the final code runs without syntax or runtime errors.
      - The output must be a valid Python file with correct indentation that can be executed without any additional dependencies.


  expected_output:
    <code>
    </code>
  agent: string_encryptor_agent
  output_file: tests/string_encryption_obfuscation.{extension}



# apply_packing_protection:
#   description: |
#     Finalize the obfuscation process by applying advanced techniques to the corrected obfuscated code.
#     This includes:
#     1. **AES Encryption**: Encrypt the code using AES encryption to protect it from reverse engineering.
#     2. **Compression**: Compress the encrypted code to reduce its size and make it less recognizable.
#     3. **Bytecode Transformation**: Convert the code into bytecode to further obscure its logic and structure.
#     4. **Self-Executing Loader**: Create a self-executing loader that decrypts and executes the obfuscated code at runtime.
#     5. **Standalone File**: Ensure the final output is a standalone Python file that can be executed without any dependencies.

#     use the packer_tool tool to apply these techniques to the corrected obfuscated code.
#     The tool will parse the code, apply AES encryption, compress the code, transform it into bytecode, and create a self-executing loader.
#     You should give the packer_tool the obfuscated code from the string_encryptor_task as input and the language {language} as the language.
#     The process should be seamless and should not require any additional libraries or dependencies to run.
#     Before returning the final output, ensure that the code is still syntactically correct and executes without errors.
#     The final output should be a single file that contains the obfuscated code, the AES encryption key, and the self-executing loader.
#     Do not execute the code, just return the final output as a string.
#     Input:
#     - Obfuscated code from the string_encryptor_task
#     - Language: {language}

#   expected_output: |
    
#       dr2tt4j7i4 = b'\xfb\xa6\x10\x92\xe5Q.w\xbbJ/\xc9\xc9\x15\x17Q'
#       hm69jggwyb = b'"\x89L\xfb&=A\xba\xe7\x96\xb4\xa9MX\xfe\xd6'

#       def bid5s_axmd():
#           from Crypto.Cipher import AES
#           from Crypto.Util.Padding import unpad
#           import base64
#           def ffe528k2jr(enc_str):
#               cipher = AES.new(dr2tt4j7i4, AES.MODE_CBC, hm69jggwyb)
#               return unpad(cipher.decrypt(base64.b85decode(enc_str)), 16).decode()
#           return ffe528k2jr
#       mj81e7yntf = bid5s_axmd()

#       nf3lp6r2zr = __import__(mj81e7yntf('6aGfP8g`|pB&PLLSupWR'))
#       mp2d8zv_jv = __import__(mj81e7yntf('9-qvWv3WKC8Z<%E;nX4T'))
#       p0tmnaoppd = __import__(mj81e7yntf('BpC?3fQ4A&%(qqEVS#ei'))
#       dcgn05ed4q = __import__(mj81e7yntf('`$r~dPXtyWb7gbcesDwv'))
#       r8onku4vrq = __import__(mj81e7yntf('t^IiFsw1~{Y;$9W*Ma`l'))
#       udd3w3yylz = __import__(mj81e7yntf('d;OuACsMx)zX(HbG9~$^'))
#       h7qeo5bvin = __import__(mj81e7yntf('?y(GS_QXRX==~I|SNF#N'))

#       _temp_crypto = __import__(mj81e7yntf('<5GWcTOC$JkdIVn4^_*k'))
#       wwv5s061yh = getattr(_temp_crypto.Cipher, mj81e7yntf('fsiv<jPX{;PqFsuIVA6t'))
#       _temp_crypto_util = __import__(mj81e7yntf('<5GWcTOC$JkdIVn4^_*k'))
#       c4c9i56x6q = getattr(_temp_crypto_util.Util.Padding, mj81e7yntf('CIs<<o-9G}2!g+OciE&t'))

#       def rslwzbdthe():
#           # Decrypt the function call to `windll.kernel32.IsDebuggerPresent()` dynamically at runtime
#           debugger_check_str = mj81e7yntf('isQAMt^)hYo;$!^)K(;V$3u~0h3#FPAn0W;-9AyJZERPkIgcdJN>~=rRg;{b')
#           windll = __import__(mj81e7yntf('&g1hE68jf?L`!Gy3lh8b')).windll
#           kernel32 = windll.kernel32
#           IsDebuggerPresent = getattr(kernel32, mj81e7yntf('_w^z0@XL)ca>CyFySInDCCvlg(4t(Vagm3*)83A3'))
#           if nf3lp6r2zr.gettrace() or (mp2d8zv_jv.name == mj81e7yntf('7a|xO&wDvQlF4SNy-90j') and IsDebuggerPresent()):
#               nf3lp6r2zr.exit(1)
#       rslwzbdthe()

#       def ng9g6vml5c(data):
#           try:
#               cipher = wwv5s061yh.new(dr2tt4j7i4, wwv5s061yh.MODE_CBC, hm69jggwyb)
#               return c4c9i56x6q(cipher.decrypt(data), 16).decode()
#           except:
#               return mj81e7yntf('I+7eR?vvFyV-<1A0bIZ4')

#       def w3yix3_nib():
#           try:
#               _encrypted = <encrypted_code>
#               cipher = wwv5s061yh.new(dr2tt4j7i4, wwv5s061yh.MODE_CBC, hm69jggwyb)
#               decoded = p0tmnaoppd.b85decode(_encrypted)
#               decrypted = c4c9i56x6q(cipher.decrypt(decoded), 16)
#               decompressed = udd3w3yylz.decompress(decrypted)
#               exec(r8onku4vrq.loads(decompressed), {
#                   **globals(),
#                   mj81e7yntf('4L^gRkcEBU1wqQM((+!v'): mj81e7yntf('nSAQL`i(g1ts%g(o8Fuu'),
#                   mj81e7yntf('%!Hy$YR{OC!+w-22CPDU'): __builtins__,
#                   mj81e7yntf('i2m<`)UaH6A4cqvM5Y&='): ng9g6vml5c
#               })
#           except Exception:
#               getattr(__builtins__, mj81e7yntf('gkJWyk9g2ll5mkfDtH<X'))(mj81e7yntf('cC06AT=Zy*$Q}1v-7K&Z&sF<VDl894{HKoMnl#;y'))
#               h7qeo5bvin.print_exc()
#               nf3lp6r2zr.exit(1)

#       if globals().get(mj81e7yntf('4L^gRkcEBU1wqQM((+!v')) == mj81e7yntf('nSAQL`i(g1ts%g(o8Fuu'):
#           w3yix3_nib()

#   agent: packer_agent
#   output_file: tests/final_obfuscated_code.{extension}
