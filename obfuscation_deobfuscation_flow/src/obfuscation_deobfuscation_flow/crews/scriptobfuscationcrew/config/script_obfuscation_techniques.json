{
  "obfuscation_techniques": [
    {
      "name": "Variable Renaming",
      "transformation_type": "structure",
      "layering_priority": 4,
      "conflicts_with": [],
      "applicability": ["python", "javascript"],
      "conditions": "Minimum identifiers: 3",
      "complexity_rating": 3,
      "description": "Replace variable and function names with randomly generated strings to hinder readability and reverse engineering.",
      "llm_prompt": {
        "task": "Apply Variable Renaming obfuscation to the given source code.",
        "steps": [
          "1. Identify all variables in the source code, including local variables, global variables, parameters, and constants.",
          "2. Rename each variable with a unique, non-descriptive name. The new names should be short, random, and lack any meaningful relationship to the original names (e.g., `a`, `b`, `x1`, `temp123`).",
          "3. Ensure that the renamed variables do not conflict with other existing variables or reserved keywords in the language.",
          "4. Replace every instance of the original variable with its new name throughout the entire code base.",
          "5. Optionally, droduce some misleading names to confuse reverse engineers (e.g., naming variables with names that seem meaningful but aren’t).",
          "6. If the variables are used across multiple files, ensure the renaming is consistent across all affected files.",
          "7. Ensure that the renamed variables retain their original behavior, and the program logic remains dact.",
          "8. Avoid any pattern or recognizable structure in the naming convention to make it harder to predict or reverse-engineer the program."
        ],
        "example": [
          {
            "before": [
              "total = 0",
              "for i in range(10):",
              "    total += i",
              "return total"
            ],
            "after": [
              "x1 = 0",
              "for y1 in range(10):",
              "    x1 += y1",
              "return x1"
            ]
          }
        ]
      }
    },

    {
      "name": "Opaque Predicates",
      "transformation_type": "control-flow",
      "layering_priority": 2,
      "conflicts_with": ["Dead Code Injection"],
      "applicability": ["python", "javascript"],
      "conditions": "Minimum control structures: 1",
      "complexity_rating": 6,
      "description": "introduce opaque predicates that evaluate to always true or false but appear complex, making the control flow harder to analyze.",
      "llm_prompt": {
        "task": "Apply Opaque Predicates obfuscation to the given source code.",
        "steps": [
          "1. Identify all conditional statements in the code (e.g., if, while, for, switch).",
          "2. Insert an opaque predicate inside these conditionals, which is a complex, seemingly true or false expression that always evaluates to a constant value (e.g., 'true' or 'false') but looks complex to understand.",
          "3. The opaque predicate should involve operations that make it hard to predict its outcome, such as mathematical operations, function calls, or logical operations.",
          "4. Ensure the condition still behaves as expected while adding the opaque predicate.",
          "5. Replace simple conditional checks with opaque predicates that will always resolve to true or false, making it harder for reverse engineers to predict the program's behavior.",
          "6. Avoid making the program logic change, so the obfuscation should not alter the final result but complicate the flow for analysis.",
          "7. Use `if (complex_expression)` or `while (complex_expression)` patterns where `complex_expression` is the opaque predicate."
        ],
        "example": {
          "before": "if (x == 5) { doSomething(); }",
          "after": [
            "opaque_condition = (x * x + 3 * x + 2) % 2 == 0",
            "if (opaque_condition):",
            "doSomething()"
          ]
        }
      }
    },
    {
      "name": "Dead Code Injection",
      "transformation_type": "structure",
      "layering_priority": 4,
      "conflicts_with": ["Opaque Predicates"],
      "applicability": ["python", "javascript"],
      "conditions": "Minimum code blocks: 2",
      "complexity_rating": 4,
      "description": "Inject non-functional code blocks that don't affect runtime behavior to mislead code readers and analysis tools.",
      "llm_prompt": {
        "task": "Apply Dead Code Injection obfuscation to the given source code.",
        "steps": [
          "1. Identify regions in the code where extra logic can be added without altering the program's behavior.",
          "2. Insert code that performs meaningless operations, such as unnecessary calculations, assignments, or function calls.",
          "3. Ensure the inserted code does not affect the overall program logic, and it should not be executed during normal runtime (e.g., by using unreachable code or conditions that always evaluate to false).",
          "4. Insert conditional statements that will always fail, like 'if (false)', or dead loops that don’t affect program flow.",
          "5. Use computations or logic that does not impact any output or final result, such as variables that are calculated but never used, or functions that are called but never return any meaningful result.",
          "6. The dead code should be convoluted enough to confuse reverse engineers and make it difficult to distinguish from functional code.",
          "7. Do not leave any noticeable traces that would indicate to the reverse engineer that the code is dentionally injected as dead code."
        ],
        "example": {
          "before": ["sum = a + b", "return sum"],
          "after": [
            "unused_var1 = a * 2 + b / 3",
            "unused_var2 = a + b - 10",
            "sum = a + b",
            "if False: dead_code = sum * 1000",
            "return sum"
          ]
        }
      }
    },
    {
      "name": "Control Flow Insertion",
      "transformation_type": "control-flow",
      "layering_priority": 3,
      "conflicts_with": [],
      "applicability": ["python", "javascript"],
      "conditions": "Minimum control flow structures: 1",
      "complexity_rating": 7,
      "description": "Insert extra control flow statements, like loops, conditionals, and switches, to make the logic of the program harder to follow.",
      "llm_prompt": {
        "task": "Apply Control Flow Insertion obfuscation to the given source code.",
        "steps": [
          "1. Identify key decision pods and control structures in the code, such as conditional statements (if-else, switch), loops (for, while), and function calls.",
          "2. Insert additional control flow structures (e.g., fake conditionals, loops, or function calls) that do not alter the program's overall behavior but make the flow of execution more complex.",
          "3. Ensure that these inserted control flows are not executed under normal conditions. Use conditions that are always true or always false (e.g., if (false), if (true)), or insert loops that terminate immediately.",
          "4. Make sure the inserted control flow structures do not alter any important data or logic, they should serve only to confuse reverse engineering efforts.",
          "5. Add irrelevant function calls or operations that do not affect the program’s output but are computationally expensive or complex enough to mislead analysis.",
          "6. Use dynamic constructs where possible, such as functions or methods that generate new code paths at runtime.",
          "7. Obfuscate the purpose of the control flow structures so they appear as though they might impact program logic, while actually serving no purpose.",
          "8. Ensure that the program's original functionality is preserved and behaves the same after the obfuscation."
        ],
        "example": {
          "before": "if x > 5:\n    doSomething()\nelse:\n    doNothing()",
          "after": [
            "if True:",
            "    temp = 10",
            "    if False:",
            "        temp = 20",
            "    # Fake logic for obfuscation",
            "if x > 5:",
            "    doSomething()",
            "else:",
            "    doNothing()",
            "if False:",
            "    dummy = 0",
            "    dummy += 1"
          ]
        }
      }
    },
    {
      "name": "Identifier Aliasing with Proxy Import",
      "transformation_type": "structure",
      "layering_priority": 5,
      "conflicts_with": [],
      "applicability": ["python"],
      "conditions": "Minimum identifiers: 3",
      "complexity_rating": 4,
      "description": "Create aliases for standard or user-defined identifiers by assigning them to randomly named variables or functions to obscure their actual purpose. Use proxy imports to further obfuscate the source code by wrapping imports in functions and assigning the imports to obfuscated variables.",
      "llm_prompt": {
        "task": "Apply Identifier Aliasing and Proxy Import obfuscation to the given source code.",
        "steps": [
          "1. Identify key variables, constants, or function names in the code that are critical to its logic.",
          "2. Create aliases for these identifiers by producing new names (e.g., `tempVar`, `hiddenFunc`) that still map to the original identifier.",
          "3. Replace all occurrences of the original identifier with its alias throughout the code.",
          "4. Use proxy imports by wrapping the import statements in functions and assigning the imports to obfuscated variables.",
          "5. Ensure that the alias is used consistently and that the original name is no longer directly visible in the code.",
          "6. Avoid making the aliases too predictable (e.g., using random or misleading names like `alpha`, `bravo`, etc.) to make it harder to trace the original variable or function names.",
          "7. If necessary, group multiple aliases for related identifiers (e.g., multiple variables or functions) under a common name or structure.",
          "8. Ensure the program behaves exactly as before, with no functional changes or side effects caused by the aliasing."
        ],
        "example": {
          "before": [
            "import numpy as np",
            "import matplotlib.pyplot as plt",
            "data = np.array([1, 2, 3, 4, 5])",
            "plt.plot(data)",
            "plt.show()",
            "mean_value = np.mean(data)",
            "print('Mean value:', mean_value)"
          ],
          "after": [
            "def proxy_numpy():",
            "    import numpy as np",
            "    return np",
            "np = proxy_numpy()",
            "",
            "def proxy_matplotlib():",
            "    import matplotlib.pyplot as plt",
            "    return plt",
            "plt = proxy_matplotlib()",
            "",
            "data_obfuscated = np.array([1, 2, 3, 4, 5])",
            "plt.plot(data_obfuscated)",
            "plt.show()",
            "mean_value_obfuscated = np.mean(data_obfuscated)",
            "print('Mean value:', mean_value_obfuscated)"
          ]
        }
      }
    }
  ]
}
