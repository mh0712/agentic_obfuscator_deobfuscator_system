{
  "technique_name": "Debug Protection Neutralization",
  "description": "Detects and removes debug protection logic, including infinite debugger loops, debugProtectionInterval traps, and anti-debugging traps. Ensures full runtime equivalence while making the code inspectable and free of anti-debugging interference.",
  "llm_prompt": "Task:\nYou are given a JavaScript source code file that contains **debug protection logic**, which may include infinite `while(true){debugger}` loops, `debugger` statements wrapped in `setInterval`, or recursive traps designed to prevent debugging and reverse engineering.\n\nYour job is to **completely remove or neutralize all such debug protection mechanisms** while keeping the rest of the application code 100% functionally intact. This includes code injected by tools like `javascript-obfuscator` using the `debugProtection` or `debugProtectionInterval` options.\n\n---\n\nYour Responsibilities:\n\n1. **Detect and remove all debugger traps**, including but not limited to:\n   - Infinite loops with `debugger` (e.g., `while (true) { debugger; }`)\n   - Self-invoking `debugger` functions (e.g., `(function(){debugger;})()`)\n   - Recursive functions invoking `debugger` on timers\n   - `setInterval(() => debugger, x)` or its function-wrapped equivalent\n\n2. **Identify known debug protection patterns**, such as:\n   - Functions calling themselves recursively with `debugger` inside\n   - Nested eval calls with debugger guards\n   - Stringified functions that insert debug traps on evaluation\n\n3. **Remove or rewrite the logic** to:\n   - No longer run `debugger` or disrupt control flow\n   - Terminate recursive loops or intervals\n   - Preserve the execution context and any real program logic not related to protection\n\n4. **Ensure runtime behavior remains unchanged**, aside from making the code debuggable again.\n\n5. Validate that:\n   - No `debugger` statement remains unless it's part of real application logic (rare)\n   - All `setInterval`, `setTimeout`, or looping protection logic is safely removed or replaced\n   - Any replaced code does not break the program or throw exceptions\n\n---\n\nAdvanced Examples:\n\n**Example 1 â€“ Infinite Debugger Loop:**\n```javascript\n(function () {\n    while (true) {\n        debugger;\n    }\n})();\n```\nâ†’ Remove entirely\n\n**Example 2 â€“ Interval-based Trap:**\n```javascript\nsetInterval(function () {\n    (function () {\n        debugger;\n    })();\n}, 4);\n```\nâ†’ Remove the interval entirely\n\n**Example 3 â€“ Self-Executing Protection Function:**\n```javascript\n(function () {\n    const protection = function() {\n        debugger;\n        protection();\n    };\n    protection();\n})();\n```\nâ†’ Remove or neutralize function so it no longer executes\n\n**Example 4 â€“ Obfuscated Recursion Trap:**\n```javascript\n(function x() {\n    try {\n        (function y(i) {\n            if (("" + i / i).length !== 1 || i % 20 === 0) {\n                (function() {}.constructor('debugger')());\n            } else {\n                debugger;\n            }\n            y(++i);\n        })(0);\n    } catch (e) {}\n})();\n```\nâ†’ Identify trap pattern and remove entirely\n\n**Example 5 â€“ Encoded Protection in Eval:**\n```javascript\n(function () {\n    eval(function(p,a,c,k,e,d){/*encoded version of debugger traps*/}(...));\n})();\n```\nâ†’ Decode and remove protection logic while preserving other code\n\n---\n\nEdge Cases:\n- Some debug traps are deeply nested in variable assignments, e.g.:\n  ```javascript\n  var a = function() { debugger; }; a();\n  ```\n  â†’ Replace only if clearly part of protection logic.\n\n- Avoid removing `debugger` statements that are part of actual development breakpoints, unless they appear in obfuscation patterns.\n\n- Some obfuscated traps use meaningless try-catch wrappers:\n  ```javascript\n  try {\n    while(true){debugger;}\n  } catch (e) {}\n  ```\n  â†’ Remove entire block.\n\n---\n\nFinal Output:\nReturn a **fully readable JavaScript source code** file with all forms of debug protection completely removed or neutralized, while maintaining full execution parity with the original script.\n\nInput Code:\n```{{language}}\n{{code}}\n```\n\n---\nOutput Code:\nReturn the cleaned, deobfuscated code with all protection logic removed. Ensure it behaves identically but is now fully debuggable and inspectable.",
  "reasoning": "The code contains anti-debugging mechanisms. Removing these will make the code debuggable and readable without altering its functional behavior."
},
{
  "technique_name": "String Decoding (XOR/Base64/Custom Obfuscation)",
  "description": "Deobfuscate and inline hidden or encoded strings that have been obfuscated using encoding mechanisms such as XOR, Base64, ROT13, percent-encoding, charCode arrays, lookup tables, or layered decoding logic. Handles custom string decoding routines used in malicious or obfuscated scripts.",
  "llm_prompt": "Task:\nPerform **advanced and complete deobfuscation** on obfuscated JavaScript code that uses **string encoding and decoding mechanisms** to hide readable strings. Your job is to:\n\n1. **Identify and extract any decoding functions or routines** in the code.\n   - Common examples include:\n     - `atob()` / `btoa()`\n     - Custom `decode(str)` functions\n     - `String.fromCharCode(...)/charCodeAt()` arrays\n     - XOR-based decoders\n     - ROT13-like rotations\n     - Percent-encoded strings (`%68%65%6C%6C%6F`)\n     - Base64, Hex, or other layerable encodings\n\n2.  **Analyze how the encoding/decoding logic works**:\n   - Inline or replace encoded strings with their decoded values.\n   - Track function calls and resolve variables used in decoding.\n   - If a decoder is built dynamically (e.g., through string concatenation, closures), reconstruct its logic.\n\n3. ðŸª„ **Decode and replace strings in-place**:\n   - Replace the use of encoded strings with **human-readable static equivalents**.\n   - If decoding depends on external input or conditions, simulate typical values or document assumptions.\n\n4.  **Support nested or layered decoding**:\n   - Handle strings that are Base64-encoded, then XORed, then re-encoded again.\n   - Unwrap decoding layers in correct order until the plaintext is fully recovered.\n\n5.  **Preserve original behavior**:\n   - Ensure the output still behaves exactly the same.\n   - Decoded strings should be statically inlined where possible, replacing decoder logic.\n\n---\n\n Examples:\n\n Obfuscated:\n```javascript\nvar s = atob('Y29uc29sZS5sb2c=');\neval(s + \"('done')\");\n```\n Deobfuscated:\n```javascript\nconsole.log('done');\n```\n\n Obfuscated:\n```javascript\nvar decode = function(x){ return x.split('').map(c => String.fromCharCode(c.charCodeAt(0)^13)).join(''); };\nvar result = decode('~}|r$');\n```\nDeobfuscated:\n```javascript\nvar result = 'test';\n```\n\n Obfuscated:\n```javascript\nvar lookup = ['r', 'e', 't', 'u', 'r', 'n'];\nvar payload = lookup.join('') + ' 5+5';\neval(payload);\n```\n Deobfuscated:\n```javascript\n(function(){ return 5+5; })();\n```\n\n Obfuscated:\n```javascript\nfunction d(x) { return decodeURIComponent(x); }\nvar secret = d('%68%74%74%70');\n```\n Deobfuscated:\n```javascript\nvar secret = 'http';\n```\n\n Obfuscated:\n```javascript\nconst x = [104, 101, 108, 108, 111];\nconst str = String.fromCharCode(...x);\n```\n Deobfuscated:\n```javascript\nconst str = 'hello';\n```\n\n---\n\nAdvanced Tricks to Detect and Handle:\n- Encoding functions built dynamically: `var f = Function('x', 'return atob(x)')`\n- XOR masks with variable keys\n- Dynamic lookup tables: `const tbl = { a: 'x', b: 'y' }; result = tbl[input]`\n- Obfuscated Base64: `'c2Ny' + 'aXB0'.replace('p', '') + '='`\n- Multiple decoders applied in sequence\n- Decoder functions that are **only built at runtime** (reconstructed from char arrays or DOM)\n- Encoded strings disguised with variable reassignments or indirect accessors\n\n---\n\n Safety Requirements:\n- Do not remove any logic if itâ€™s necessary for decoding or runtime behavior.\n- Inline statically resolvable decoded values.\n- Leave warnings or TODOs for strings that could not be safely decoded.\n- Reconstruct behavior to **match output exactly**, even if code structure changes.\n\n---\n\n Tips:\n- Use partial evaluation to simulate decoding where needed.\n- Try decoding all known common encoding formats.\n- Inline decoded strings to simplify and clarify logic.\n\nInput code:\n```{{language}}\n{{code}}\n```",
  "reasoning": "The code employs Base64 encoding to obfuscate strings, and decoding these will make the code much more intelligible. Using this technique allows for retrieving and inlining readable string values, enhancing code clarity."
},
{
  "technique_name": "Variable Recovery",
  "description": "Recover meaningful variable names and restore semantic clarity in code that has been obfuscated by aggressive renaming, scope hiding, shadowing, or minification. Variable usage, purpose, and type should be inferred based on context and usage patterns.",
  "llm_prompt": "Task:\nYou are given an obfuscated JavaScript code with meaningless variable names, reused variable identifiers, or confusing scoping and shadowing. Your job is to **recover the original intent behind variables** by:\n\n1. **Inferring meaningful names** from:\n   - Variable values or assignments\n   - Function names and roles\n   - Literal values assigned (e.g., 'url', 'token', 'handler')\n   - Comments (if available)\n   - Context within loops, conditions, and DOM/API operations\n\n2. ðŸ§¹ **Deobfuscating misleading or reused identifiers**:\n   - Identify and rename variables with context-based names (e.g., `a` â†’ `username`, `b` â†’ `response`)\n   - Disambiguate shadowed variables (e.g., a local `data` inside a global `data`)\n   - Avoid name collisions and preserve scope integrity\n   - Use scoped naming where appropriate (e.g., `counter` in loop vs. `mainCounter` globally)\n\n3. **Preserving behavioral equivalence**:\n   - Do **not** change logic, flow, or runtime behavior\n   - Ensure renamed variables are consistent across references\n   - Keep functionally dynamic or reflective code safe (e.g., `window['someVar']` or `eval` references)\n\n4. **Make the code semantically meaningful and readable**:\n   - Avoid generic names like `data1`, `data2` unless unavoidable\n   - Infer domain-specific semantics where possible (e.g., if a value is assigned a URL string, consider `url`, `endpoint`, or `apiPath`)\n   - If variable's meaning is unclear, use descriptive fallbacks like `tempValue`, `intermediateResult`, `flag`, etc.\n\n---\n\n Examples:\n\n Obfuscated:\n```javascript\nvar a = 'john';\nvar b = 5;\nfunction c(d){ return d * b; }\nconsole.log(a);\n```\n Recovered:\n```javascript\nvar username = 'john';\nvar multiplier = 5;\nfunction multiply(input){ return input * multiplier; }\nconsole.log(username);\n```\n\n Obfuscated:\n```javascript\nfunction a(b){\n  var c = b + 10;\n  return c;\n}\nvar d = a(5);\n```\n Recovered:\n```javascript\nfunction addTen(number){\n  var result = number + 10;\n  return result;\n}\nvar finalValue = addTen(5);\n```\n\n Obfuscated:\n```javascript\nvar x = { a: 1, b: 2 };\nvar y = x.a + x.b;\n```\n Recovered:\n```javascript\nvar config = { retries: 1, timeout: 2 };\nvar totalWaitTime = config.retries + config.timeout;\n```\n\n Obfuscated:\n```javascript\nfunction e(e) {\n  var e = 123;\n  return e;\n}\n```\n Recovered:\n```javascript\nfunction getNumber(input) {\n  var number = 123;\n  return number;\n}\n```\n\n---\n\n Advanced Techniques to Handle:\n- Minified loops: `for(var i=0;i<n;i++){}` â†’ `for (let index = 0; index < count; index++) {}`\n- Reused letters like `l`, `O`, `I` meant to confuse visually\n- Overloaded `var a = function a() {}` cases\n- Pattern-based inference (e.g., if var `t = new XMLHttpRequest()`, then `t` â†’ `xhr`)\n- Deep scope tracing to detect name reuse or incorrect inference\n\n---\n\n Guidelines:\n- Always rename variables consistently throughout the scope\n- Never break runtime behavior\n- Avoid guessing too muchâ€”fallback to safe names if unsure\n- Favor descriptive names, even long ones, over unclear shorthand\n\nInput Code:\n```{{language}}\n{{code}}\n```",
  "reasoning": "The code is using obfuscated variable names, making it difficult to understand its purpose. This technique aids in recovering meaningful and context-driven names for variables, improving readability."
}
