```json
[
    {
        "technique_name": "Variable Renaming",
        "description": "Replace variable and function names with randomly generated strings to hinder readability and reverse engineering.",
        "parameters": {
            "name_length": 8,
            "allowed_characters": "abcdefghijklmnopqrstuvwxyz_0123456789"
        },
        "llm_prompt": "Task:\nApply variable renaming to the following code by replacing all function names, parameter names, and variable names with unique, meaningless identifiers.\nConstraints:\n- All new names must be exactly {{name_length}} characters long.\n- Only use lowercase letters from this set: \"{{allowed_characters}}\".\n- Avoid Python/JavaScript keywords and built-in names.\n- Ensure the obfuscated code remains functional and syntactically valid.\n- Do not alter string literals, comments, or any external API/library names.\n- Maintain formatting and indentation of the original code.\n\n Input code:\n```{{language}}\n{{code}}\n```\n",
        "layering_priority": 6,
        "metrics_score": 8,
        "reasoning": "This technique is compatible with Python, meets the condition of having at least 3 identifiers, and does not conflict with other selected techniques."
    },
    {
        "technique_name": "String Encryption",
        "description": "Encrypt or encode all string literals using a reversible method, storing them in variables or decoding functions to prevent static analysis.",
        "parameters": {
            "method": "base64",
            "variable_name_length": 8,
            "allowed_characters": "abcdefghijklmnopqrstuvwxyz"
        },
        "llm_prompt": "Task:\nObfuscate the following code by encrypting all string literals using the {{method}} encoding technique. Inject lightweight runtime decoding logic to restore original strings dynamically during execution.\nConstraints:\n- Apply encryption to all plain string literals, including:\n      - Printed messages\n      - Assignments\n      - Return values\n      - Conditionals and comparisons\nDo NOT encode:\n- Import/module/include statements\n- External file paths or URLs\n- Documentation strings or annotations\n  Ensure encoded strings are not recognizable at a glance (e.g., no clear base64/plaintext chunks).\n  Place decoder logic in a non-obvious location (e.g., in a helper function or a lambda).\n  Decoder must execute just-in-time, restoring strings only when needed.\n\nExample Transformations:\nPython (with Base64):\nimport base64\ndef axz(s): return base64.b64decode(s).decode()\nprint(axz(\"SGVsbG8sIHdvcmxkIQ==\"))\nJavaScript (with XOR):\n\njavascript\nfunction jg(x){return x.split('').map(c=>String.fromCharCode(c.charCodeAt(0)^42)).join('');}\nconsole.log(jg(\"\\u001f\\u000f\\u0017\\u0017\"));\n\n Input code:\n```{{language}}\n{{code}}\n```\n",
        "layering_priority": 8,
        "metrics_score": 9,
        "reasoning": "String Encryption is highly suitable given the presence of 9 string literals. It provides a significant layer of data obfuscation, aligning with the script's complexity level."
    },
    {
        "technique_name": "Opaque Predicates",
        "description": "Introduce opaque predicates that evaluate to always true or false but appear complex, making the control flow harder to analyze.",
        "parameters": {
            "insertion_frequency": "moderate",
            "predicate_type": "always_true",
            "variable_name_length": 8,
            "allowed_characters": "abcdefghijklmnopqrstuvwxyz"
        },
        "llm_prompt": "Task:\nObfuscate the following {{language}} code by injecting opaque predicates that:\n- Add conditional logic that always evaluates to {{predicate_type}}.\n- Are resistant to static analysis, symbolic execution, and pattern matching.\n- Do not affect the actual execution flow of the original program.\n\nOpaque predicates must include:\n- Non-trivial math (e.g., modulo with large primes, bit tricks).\n- Environment-based values (e.g., timestamps, system state) when possible.\n- All opaque branches that donâ€™t affect execution must contain no-ops, decoy logic, or junk calls (e.g., unreachable dummy functions).\n- Any helper variables or functions must use meaningless {{variable_name_length}}-character names composed from the character set \"{{allowed_characters}}\".\n- Maintain full semantic equivalence and ensure the final code is valid and executable.\n\nExamples of opaque predicates:\nPython:\n# Always True: XOR with self is 0\nif ((1337 ^ 1337) == 0):\n    pass\n\n# Always False: 1234 AND 0 is 0\nif ((1234 & 0) != 0):\n    pass\n\n# Always True: String lengths match\nif (len(\"obfuscation\") == len(\"obfuscation\")):\n    pass\n\n# Always True: Modulo trick\nif ((42 * 17 + 1) % 17 == 1):\n    pass\n\n# Always False: ID of two different objects is never equal\nif (id(object()) == id(object())):\n    pass\n\n# Always True: Functionally obscure\nif (all([True for _ in range(3)]) and not False):\n    pass\n\nJavaScript:\n      // Always True: 999 ^ 999 === 0\n  if ((999 ^ 999) === 0) {\n      // true\n  }\n\n  // Always False: Random-looking logic, but known result\n  if (((Math.floor(Date.now()) % 2) + 1) === 3) {\n      // false\n  }\n\n  // Always True: x ^ x = 0\n  let x = 123;\n  if (((x ^ x) + 0) === 0) {\n      // true\n  }\n\n  // Always False: Empty string !== ' '\n  if ('' === ' ') {\n      // false\n  }\n\n  // Always True: type coercion with number\n  if (parseInt(\"0x2A\") === 42) {\n      // true\n  }\n\n  // Always True: Random-seeming math, but deterministic\n  if (((2 << 3) / 4) === 4) {\n      // (2 * 8) / 4 = 16 / 4 = 4\n  }\n\n Input code:\n```{{language}}\n{{code}}\n```\n",
        "layering_priority": 2,
        "metrics_score": 7,
        "reasoning": "Opaque Predicates effectively obscure control-flow analysis given the availability of control structures, aligning with the need for control-flow transformation within the script."
    },
    {
        "technique_name": "Control Flow Insertion",
        "description": "Insert extra control flow statements, like loops, conditionals, and switches, to make the logic of the program harder to follow.",
        "parameters": {
            "max_insertions": 3,
            "insertion_probability": 0.2,
            "insertion_depth": 2
        },
        "llm_prompt": "Task:\nObfuscate the following {{language}} code by adding extra control flow statements, such as loops, conditionals, or switches.\n- The goal is to obscure the flow of control and add non-essential operations.\n- Avoid modifying or altering the original functionality of the code.\n- Make sure the inserted control flow is non-trivial and looks plausible.\n\nConstraints:\n- Insert at most {{max_insertions}} extra flow control structures (e.g., loops, if-statements, switches).\n- Ensure the control structures do not change the actual logic of the program.\n- Insert control flow at random points in the code (e.g., before or after function calls, within functions, etc.).\n- Use different types of control structures for diversity (e.g., `for` loops, `while` loops, `switch` statements).\n\nExample transformations:\nBefore:\nif x > 5:\n    print(\"Success\")\nAfter:\nif random.choice([True, False]):\n    if x > 5:\n        print(\"Success\")\n    else:\n        print(\"Failure\")\nelse:\n    if x < 10:\n        print(\"Out of bounds\")\n\n Input code:\n```{{language}}\n{{code}}\n```\n",
        "layering_priority": 3,
        "metrics_score": 6,
        "reasoning": "The Control Flow Insertion technique is applicable given the presence of control structures, adding complexity without affecting functionality."
    },
    {
        "technique_name": "Function Outlining",
        "description": "Break down complex functions into smaller, less meaningful helper functions to increase confusion and reduce analysis accuracy.",
        "parameters": {
            "min_functions": 2,
            "function_name_length": 8
        },
        "llm_prompt": "Task:\nObfuscate the following {{language}} code by breaking complex functions into smaller helper functions.\n- Each helper function should have a meaningless name and perform a small, seemingly unrelated task.\n- Do not alter the overall functionality of the program.\n- Use random names for each new function (generated from {{function_name_length}}-character strings).\n\nConstraints:\n- Create at least {{min_functions}} new helper functions.\n- Ensure the new functions do not directly reveal the main logic of the program.\n- Do not introduce any additional external dependencies.\n\nExample Transformation:\nBefore:\ndef process_data(x, y):\n    return x * y + 10\n\nAfter:\ndef hghvbnfg(x):\n    return x * 2\n\ndef akjdhgl(x):\n    return x + 10\n\ndef process_data(x, y):\n    return akjdhgl(hghvbnfg(x) + y)\n\n Input code:\n```{{language}}\n{{code}}\n```\n",
        "layering_priority": 1,
        "metrics_score": 6,
        "reasoning": "Function Outlining aids in confusing code analysis by breaking functions into smaller segments, supported by the script's presence of multiple functions."
    }
]
```