input_analysis_task:
  description: |
    using detect_code_format_tool tool, The task is to analyze the provided code input from {file_path}. The process involves multiple steps:
    1. **Code Type Detection**: Is the input a script or binary? Analyze the structure and headers to identify this.
    2. **Language Detection**: What programming language is the code written in? This includes determining whether it's Python, JavaScript, or something unknown.
    3. **Obfuscation Detection**: Does the code appear to be obfuscated? This requires looking for patterns that suggest code has been altered for the purpose of hiding its logic.

    Each of these steps should be validated using syntax patterns, encoding anomalies, and variable naming conventions.

  expected_output: |
    {
      "code_type": "script" | "binary",
      "language": "python" | "javascript" | "unknown",
      "is_obfuscated": true | false
    }

  agent: input_parser
# =============================================================================================================================
# ----------------------------------------------------Code Obfuscation Tasks----------------------------------------------------
# =============================================================================================================================
code_complexity_analysis_task:
  description: |
    Given the input code {code}, we need to assess its complexity through the following steps:
    1. **Cyclomatic Complexity**: Calculate the overall complexity based on the control structures and functions in the code. The higher the cyclomatic complexity, the more challenging the code is to obfuscate.
    2. **Nesting Depth**: Assess the depth of nesting in control structures such as loops and conditionals. Excessive nesting can complicate obfuscation techniques and potentially hinder code readability.
    3. **Code Structure**: Count the number of functions, classes, and code blocks to understand the overall organization of the code. A large number of functions or classes can indicate higher complexity and suitability for certain obfuscation techniques.
    4. **Obfuscation Suitability**: Flag the suitability of obfuscation techniques based on the structure and complexity of the code. This includes flags like the presence of identifiers, functions, string literals, and other key structures that make the code more complex and suitable for obfuscation.
    5. **Error Handling**: The tool should also handle syntax errors gracefully and return an error message if the code is malformed.

    Return the complexity metrics and applicability flags for obfuscation techniques that are relevant to the current code.

  expected_output: |
    {
      "complexity_metrics": {
        "lines": number,
        "functions": number,
        "classes": number,
        "cyclomatic_complexity": number,
        "variables": number,
        "identifiers": number,
        "strings": number,
        "literals": number,
        "booleans": number,
        "control_structures": number,
        "code_blocks": number,
        "nesting_depth": number
      },
      "applicability_flags": {
        "min_identifiers": true | false,
        "min_functions": true | false,
        "min_string_literals": true | false,
        "min_literals": true | false,
        "min_code_blocks": true | false,
        "min_control_structures": true | false,
        "min_boolean_expressions": true | false,
        "max_nesting_depth": true | false
      },
      "error": string | null
    }
  agent: complexity_analyzer
  output_file: complexity_analysis_output.json

technique_selection_task:
  description: |
    Based on the analysis results, evaluate and select the best obfuscation techniques for this code. The reasoning should follow these steps:
    1. **Language Compatibility**: Does the technique support the programming language of the code (Python or JavaScript)?
    2. **Complexity Suitability**: Does the technique align with the complexity metrics identified in the previous task?
    3. **Precondition Check**: Does the technique require any specific conditions to be met (e.g., minimum number of identifiers or literals)?
    4. **Conflict Resolution**: Are there any conflicting techniques? If so, choose the one that best fits the code structure.
    5. **Diversity of Techniques**: Ensure a balance of transformation typesâ€”data, structure, control-flowâ€”to maximize obfuscation resilience.
    6. **Layering Priority**: Ensure that techniques are applied in the correct order according to their priority.

    Reasoning should be clear: if a technique is selected, provide a justification for its inclusion.
    These techniques should be selected from the below JSON knowledge base that contains a list of obfuscation techniques, their descriptions, parameters, and layering priorities:
    {obfuscation_techniques}

  expected_output: |
    [
      {
        "technique_name": "Technique 1",
        "description": "Brief explanation of the technique",
        "parameters": {
          "param1": value,
          "param2": value
        },
        "llm_prompt": "Instruction on how to apply this technique",
        "layering_priority": 1,
        "metrics_score": score,
        "reasoning": "Explanation for selecting this technique"
      },
      ...
    ]
  output_file: selected_techniques.json
  agent: technique_selector

code_obfuscation_task:
  description: |
    Now that the techniques have been selected, we need to apply them to the code in a sequential manner based on their layering priority.
    Each technique should be applied in turn, and the output of one step should be used as input for the next. The process involves:
    1. **Obfuscation Layering**: Start with the first technique and apply it to the original code.
    2. **Sequential Application**: After each technique, verify the output and apply the next technique, ensuring that the code's functionality is preserved at every step.
    3. **Functionality Preservation**: Ensure that after applying each technique, the obfuscated code behaves the same as the original code.

  expected_output: |
    <code>
    # Final obfuscated code here
    </code>

  output_file: obfuscated_code.js
  agent: obfuscation_llm

excecution_validator_task:
  description: |
    Given the obfuscated code given by the code_obfuscation_task task, we need to ensure that the code is syntactically correct and that it excecutes without any runtime errors:  by:
    1. **Parsing**: Checking whether the code is valid according to the syntax rules of its programming language (Python or JavaScript).
    2. **Error Identification**: Identifying specific syntax errors if they exist, including line numbers and error types.
    3.**Execution**: Run the code in a controlled environment.
    4. **Error Handling**: If runtime errors occur, capture error messages or stack traces.

    The task will output whether the code is syntactically correct or not, and if not, provide details about the errors found.
    In addition, The task will output whether the code executes successfully without errors or if errors are encountered during execution.

  expected_output: |
    {
      "is_valid_syntax": true | false,
      "syntax_error": {
        "line_number": number,
        "error_type": string,
        "error_message": string
      } | null,
      "runs_without_error": true | false,
      "runtime_error": {
        "error_type": string,
        "stack_trace": string
      } | null
    }
  agent: execution_validator
  output_file: execution_validation_result.json

semantic_equivalence_test_task:
  description: |
    Given the original code {code} and the obfuscated code given by the code_obfuscation_task task , we need to:
    1. **Generate Unit Tests**: Create a suite of unit tests to cover typical and edge cases for both versions.
    2. **Run Tests**: Execute the unit tests on both the original and obfuscated versions of the code.
    3. **Comparison**: Compare the outputs of both versions to ensure they match under identical inputs.

    The task will output whether the unit tests pass for both versions and whether the outputs are identical.

  expected_output: |
    {
      "semantically_equivalent": true | false,
      "test_results": [
        {
          "test_name": string,
          "input": any,
          "original_output": any,
          "obfuscated_output": any,
          "match": true | false
        }
      ],
      "error": string | null
    }
  agent: semantic_equivalence_validator
  output_file: semantic_equivalence_result.json

feedback_loop_task:
  description: |
    Based on the failed verification results from the excecution validatior task, runtime error checks, and also the unit test comparisons results from the semantic_equivalence_test_task task, we will:
    1. **Analyze Errors**: Review the details of failed tests or errors in syntax/runtime.
    2. **Recommend Adjustments**: Suggest changes to the obfuscation techniques or parameters.
    3. **Modify Obfuscation**: Based on the feedback, suggest which techniques need to be applied differently or adjusted.

    The task will output recommendations for improving the obfuscation process.

  expected_output: |
    {
      "recommendations": [
        {
          "suggested_action": string,
          "reason": string
        }
      ]
    }
  agent: feedback_loop_agent
  output_file: feedback_loop_result.json

final_obfuscation_task:
  description: |
    You are an obfuscation agent.

    Your job is to refine previously obfuscated code **without making it more readable or undoing obfuscation**.

    **Reason**:
    - The code was obfuscated intentionally for security or intellectual property protection.
    - Previous validation steps flagged issues (e.g., syntax errors, runtime errors, or incorrect outputs).
    - Your goal is to make the code syntactically valid, runtime-correct, and semantically equivalent to the original â€” **without reducing its complexity or revealing its intent**.

    **Action**:
    - DO NOT simplify variable names, logic, or structure.
    - ONLY fix syntax issues, execution bugs, or semantic mismatches.
    - Preserve obfuscation: retain unreadable names, unnecessary-looking control flows, and encoded strings.
    - Ensure that the code passes all unit tests and runs correctly.

    ---
    Proceed by analyzing the current obfuscated code and applying only the minimum necessary changes.

  expected_output: |
    <code>
    # Final obfuscated code here
    </code>
    Ensure that the code is syntactically correct, executes without errors, and passes all unit tests.
  agent: obfuscation_llm
  output_file: corrected_obfuscated_code.js

apply_obfuxtreme_protection:
  description: >
    Finalize the obfuscation process by applying advanced multi-layer protection techniques
    to the corrected obfuscated code, supporting both **Python** and **JavaScript**.

    This includes:
    1. **AES Encryption**: Encrypt the code using AES encryption to protect it from reverse engineering.
    2. **Compression**: Compress the encrypted code to reduce its size and make it less recognizable.
    3. **Bytecode Transformation** (Python only): Convert Python code into bytecode to further obscure its logic and structure.
    4. **Self-Executing Loader**: Create a self-executing loader that decrypts, decompresses, and executes the code at runtime.
    5. **Standalone File**: Ensure the final output is a standalone file that can be executed without any external dependencies.

    Use the `obfuxtreme_finalizer` tool to apply these techniques to the corrected obfuscated code from the previous task.
    The tool should be able to handle both Python and JavaScript code.

    **Important**:
    - For Python: Use AES + compression + marshal or bytecode execution for maximum protection.
    - For JavaScript: Use AES + compression + dynamic eval/Function constructor for execution.
    - The final output must embed the encrypted payload, AES keys, and the loader logic inside a single executable script.
    - Ensure the final script is syntactically correct and runs without errors.

  expected_output: |
    <code>
    # The fully protected, standalone encrypted version of the code.
    </code>

  agent: obfuxtreme_agent
  output_file: obfuscated_final.js

# =============================================================================================================================
# ----------------------------------------------------Binary Obfuscation Tasks-------------------------------------------------
# =============================================================================================================================
extraction_task:
  name: "Binary Feature Extraction"
  description: |
    Extract control flow, function-level details, and instruction-level data from the binary at {binary_path} using Ghidra scripts.
  expected_output: |
    {
      "functions": [
        {
          "name": "func_name",
          "blocks": [
            {
              "start": "0x...",
              "end": "0x...",
              "instructions": [...],
              "type": "entry|normal|exit",
              "successors": [...],
              "calls": [...]
            }
          ]
        }
      ]
    }
  agent: binary_analysis_agent

binary_technique_plan_task:
  name: "Obfuscation Planning"
  description: |
    Using  the extracted CFG and instruction-level data,
    Choose ALL the suitable obfuscation techniques from the provided knowledge base: {obfuscation_techniques}.
    Take all the present field values in the knowledge base fully into account not just part of them.
    Each selected technique must include:
    - technique_name
    - function_name 
    - description
    - reasoning
    - exampleOriginal: original code snippet
    - exampleObfuscated: obfuscated code snippet
    - implementationNotes: notes on how to implement the technique
    - ghidraSample: Ghidra code snippet for the technique
  expected_output: |
    [
      {
        "technique_name": "Control Flow Flattening",
        "description": "...",
        "reason": "Suitable for obfuscating multi-path logic...",
        "implementationNotes": [],
        "ghidraSample": {
          "javaMethod": "techniqueName",
          "code": []
        }
      }
    ]
  output_file: selected_techniques.json
  agent: binary_technique_planner_agent

plan_binary_obfuscation_patches:
  name: "Plan Binary Obfuscation Patch Locations"
  description: |

    **Goal**:
    You are tasked with generating a valid and safe **patch plan** for applying binary-level obfuscation to a target executable. 
    This plan will later be used by another agent to generate an executable Ghidra script that modifies the binary. Your plan must define **where** and **what** to patch, using only known safe memory regions.

    ---

    ### ðŸ”§ Inputs

    * **Binary path**: `{binary_path}`
    * **Free memory regions** (provided as JSON by find_free_memory_tool):

      * `free_memory_ge12.json`: regions â‰¥ 12 bytes (use these for Dead Code Insertion Techniques)
      * `free_memory_lt12.json`: regions < 12 bytes (use these for Arithmetic Branch Replacement Techniques)
      * `conditional_branches.json`(provided by the find_conditional_branches_tool): contains all conditional branches in the binary. Use these to identify potential replacement targets for branch replacement techniques.

    * **Selected techniques**: `selected_techniques.json` given by  binary_technique_plan_task contains implementation details of the obfuscation techniques selected for this binary.

    ###Requirements

    1. **Use only available free memory**

      * All insertions must target addresses inside the provided free memory regions.
      * Replacements of existing code are discouraged unless the region is fully verified safe.

    2.Use Pattern from the selected techniques to generate the patch plan.

      * Each technique must be applied in a way that matches its description and requirements.
      * Use the provided JSON knowledge base to ensure correct implementation.
      * The patch plan must include all necessary operands, including registers, constants, and labels.

    3. **Precision is critical**

      * Instruction sizes must **exactly match** the available byte count.
      * Use the byte-length mapping table below to determine allowable instructions.

    3. **Output Format**:
      Produce a JSON **array**. Each entry should be a complete patch plan for one technique:

      ```json
    Each element in the output array must follow this structure:

    - type: (string) Name of the obfuscation technique used (e.g., "junk insertion")
    - addresses:
        - insert: (optional list) List of insertion patches:
            - address: (string) Virtual address within a free memory region (e.g., "0x140001568")
            - instructions: (list of strings) Assembly mnemonics to insert at the given address
        - replace: (optional list) List of live instruction replacements:
            - address: (string) Address of the original instruction to replace
            - instruction: (string) The original instruction at that address
            - replacement: (list of strings) New instructions that replace the original
    - operands:
        - registers: (list of strings) Registers used in this patch
        - constants: (list of numbers) Constants or immediate values used
        - labels: (list of address strings) Addresses used as control-flow targets
    - layer: (integer) Application order index; lower numbers are applied earlier

      ```

    ###Critical Constraints

    * **Do NOT exceed available bytes** in any memory region.
    * **Do NOT include label names** directly in instruction stringsâ€”labels must be provided as raw addresses in the `labels` list.

    ```json
    {
      "MOV": 3, "ADD": 3, "SUB": 3, "XOR": 3, "IMUL": 4, "CMP": 3,
      "TEST": 3, "JMP": 5, "JE": 5, "JZ": 5, "JNE": 5, "JA": 5, "JB": 5,
      "CALL": 5, "RET": 1, "NOP": 1, "HLT": 1, "WAIT": 1, "LOCK": 1,
      "PUSH": 2, "POP": 2, "AND": 3, "OR": 3, "NOT": 3, "SHL": 3,
      "SHR": 3, "SAR": 3, "ROL": 3, "ROR": 3,
      "MOVSB": 1, "MOVSW": 1, "MOVSD": 1, "MOVSQ": 1
    }
    ```

    * Instructions may be grouped into one insert block only if their **total byte size exactly fits** the target region.

    IMPORTANT: All assembly instructions must be compatible with Ghidraâ€™s Sleigh assembler.
    Avoid using BYTE PTR, DWORD PTR, MOVABS, or any MASM/NASM-specific syntax.
    Use simple forms like MOV [0xADDRESS], REGISTER or TEST [0xADDRESS], IMM.
    Use MOV REG, IMM for immediate moves. Stick to uppercase opcodes.


    ### Layered Obfuscation Support

    Each object must specify a `"layer"` integer to define patch order:

    * `0` = apply first
    * `1` = apply after layer 0
    * And so on...

    ---
    **Final Notes**:

    * This patch plan will be used to generate **real binary patches**, so it must be:

      * **Accurate**
      * **Size-matched**
      * **Safe**
      * **Syntactically valid JSON**

    Any invalid address, instruction, or structure may corrupt the binary.



  expected_output: |
    A JSON array where each object contains:
      - "type": obfuscation technique name
      - "addresses": insert/replace info, including exact VA and instructions
      - "operands": all used registers, constants, and label targets
      - "layer": obfuscation layer index (order)

  agent: binary_patch_planner_agent
  output_file: patch_locations.json


apply_obfuscations_task:
  name: "Generate Ghidra Patch Script"
  description: |
    Generate a Java-based Ghidra script named **ApplyObfuscationTechniques.java** (with a public class `ApplyObfuscationTechniques` extending `GhidraScript`) that applies multiple binary-level obfuscation techniques using the Ghidra scripting API. The obfuscation steps must follow the patching instructions defined in a plan provided by `plan_binary_obfuscation_patches`. The output must be only the complete source codeâ€”no comments, no explanations.

    **High-Level Requirements**  
    - A single public class named `ApplyObfuscationTechniques extends GhidraScript`.  
    - Script must apply binary patches based on the patch plan from `plan_binary_obfuscation_patches`.  
    - No GUI or user input.  
    - At the end of `run()`, invoke `runScript("RenameVariablesObfuscation.java");`.  

    **Setup in `run()`**  
    1. Declare a class-level field:  
      ```java
      private Assembler asm;
      ```  
    2. Inside `run()`, initialize it once:  
      ```java
      asm = Assemblers.getAssembler(currentProgram);
      ```  

    **Obfuscation Methods**  
    - Implement each obfuscation technique from the plan in its own `private void` method  
    - if you need to use a patchInstructions function, write it this way:
    **Helper Method**  
    ```java
    private void patchInstructions(String address, String[] instructions) throws Exception {
        Address addr = toAddr(address);
        Listing listing = currentProgram.getListing();
        for (String instruction : instructions) {
            asm.assemble(addr, instruction);
            Instruction inserted = listing.getInstructionAt(addr);
            if (inserted == null) {
                printerr("Failed to fetch instruction at: " + addr);
                break;
            }
            println("Patched at " + addr + ": " + instruction);
            addr = addr.add(inserted.getLength());
        }
    }
    ```  

    **Label Usage**  
    - Do not use label syntax in the instruction strings. To define a label, use:  
      ```java
      createLabel(toAddr("0x140001600"), "dispatcher_label", true);
      ```  

    **Instruction Syntax**  
    - Use uppercase Intel-style x86-64 mnemonics (`NOP`, `MOV`, `ADD`, `CMP`, `JMP`, etc.).

    **Allowed Imports Only**  
    ```java
    import ghidra.app.script.GhidraScript;
    import ghidra.app.plugin.assembler.*;
    import ghidra.program.model.address.*;
    import ghidra.util.exception.*;
    import ghidra.program.model.listing.*;
    ```  

    **Final Output**  
    Output only the complete, executable Java class source code for `ApplyObfuscationTechniques.java`, including:  
    - The `run()` method calling each obfuscation technique method and ending with `runScript(...)`.  
    - Each obfuscation technique in its own `private void` method.  
    - The `patchInstructions(...)` helper (Optional)
    - No surrounding explanation or markdownâ€”just the Java source.
    

  expected_output: |
    The script must be a fully functional and directly executable Ghidra Java script named `ApplyObfuscationTechniques.java`. The output must include only the **entire source code**, formatted as a complete Java classâ€”no explanations, comments, or diagnostic output:
    ```java
    import ghidra.app.script.GhidraScript;
    import ghidra.app.plugin.assembler.*;
    import ghidra.program.model.address.*;
    import ghidra.util.exception.*;
    import ghidra.program.model.listing.*;
    import ghidra.util.exception.*;
    import ghidra.program.model.listing.*;

    private class ApplyObfuscationTechniques extends GhidraScript {
        private Assembler asm;

        @Override
        public void run() throws Exception {
            asm = Assemblers.getAssembler(currentProgram);
           .......
            ``` add your obfuscation techniques here ```
            .......
            runScript("RenameVariablesObfuscation.java");
        }

        private void insertDeadCode() throws Exception {
            .....
        }

        .......
    }
    ```

  agent: ghidra_patch_agent
  output_file: ghidra_scripts/ApplyObfuscationTechniques.java


patching_task:
  name: "Patch Transformed Binary"
  description: |
    First, Use Ghidra to run ApplyObfuscationTechniques.java on the binary usi
    This will apply the bytecode transformations, reassemble the binary, and save it to:
    C:\Users\celin\Desktop\usj\FYP\agentic_obfuscator_deobfuscator_system\agentic_obfuscator_deobfuscator\src\obfuscation_deobfuscation_crew\tools\ghidra_output\obfuscated_binary.exe
  expected_output: |
    Binary successfully patched and exported to obfuscated_binary.exe
  agent: ghidra_patch_agent

# semantic_validation_task:
#   name: "Post-Obfuscation Validation"
#   description: |
#     Symbolically or heuristically analyze the obfuscated binary and compare with the original binary.
#     Techniques may include:
#     - Dynamic function call traces
#     - Symbolic instruction equivalence
#     - Decompiler-based comparison
#     Provide a report indicating any semantic mismatches or functional divergence.
#   expected_output: |
#     {
#       "validation_status": "Pass|Fail",
#       "equivalence_score": 0.0 - 1.0,
#       "issues": [
#         { "function": "foo", "reason": "Control flow altered" }
#       ]
#     }
#   agent: binary_analysis_agent

