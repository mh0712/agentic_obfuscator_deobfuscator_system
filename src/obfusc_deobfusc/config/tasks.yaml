detect_format:
  description: "Detect if the file is binary, Python, or JavaScript and determine if it is obfuscated."
  expected_output: "JSON object with the following keys: 'language', 'type', 'obfuscated'."
  agent: "input_parser_agent"

execute_code:
  description: |
    The task involves executing the obfuscation techniques on the provided code using the
    specified tools and methods. The techniques to be applied are gathered from a web search agent,
    and a large language model (LLM) will be used to process the code, apply the obfuscation techniques,
    and produce the obfuscated output. The goal is to make the code more secure, harder to analyze, and
    resistant to deobfuscation techniques.
  expected_output: |
    The expected output is an obfuscated version of the input code. The obfuscation should render the code
    more difficult to understand or reverse-engineer while maintaining the functionality of the original code.
    The obfuscated code should be in a format that is compatible with the execution environment, ensuring that 
    it can be tested and run to verify that the functionality is preserved.
  agent: "executer_agent"

web_search:
  description: |
    Act as an advanced cybersecurity researcher specializing in code obfuscation.
    Retrieve all types of obfuscation techniques for Python applicable in scripts.
    Instead of just descriptions, generate a structured prompt that another LLM can use to apply the technique dynamically.
    Ensure that the prompt includes:
    - A clear explanation of the technique.
    - Step-by-step implementation details.
    - Constraints and edge cases to consider.
    - Example input and expected output after obfuscation.
    - Any special considerations for execution.
    Return the results in the following JSON format:
    "techniques": [
      {{
        "name": "<technique_name>",
        "applicability": ["Python"],
        "deobfuscation_risk": <1-10>,
        "llm_prompt":
        Act as a code transformation AI. Apply the following obfuscation technique: <technique_name>.
        \nPurpose: <Explain why this technique is used>
        \nSteps:
        1. <Step 1 to modify the code>
        2. <Step 2...>
        3. <Finalizing changes>
        \nConstraints:
        - Maintain original code functionality.
        - Ensure compatibility with python.
        \nExample:
        Input:
        ```
        <advanced example input code>
        ```
        Output:
        ```
        <expected output code>
        ```
      }}
    ]
    Remember you should give an advanced example to use known obfuscation techniques like variable renaming, opaque predicates, controlflow flatenning, dead code injection,data encryption and more... Simple obfuscation techniques might be reversed easily.
  expected_output: |
    The expected output is a structured list of obfuscation techniques for Python that can be applied to scripts.
    Each technique should include the following details:
    - Name of the technique.
    - Applicability (must specify that it applies to Python).
    - A deobfuscation risk rating between 1 and 10.
    - A detailed LLM prompt that includes:
      - Purpose of the technique.
      - Step-by-step instructions on how to apply the technique.
      - Constraints (e.g., maintaining functionality and ensuring Python compatibility).
      - Example input and output before and after obfuscation.
    The result should be in a JSON format with an array of techniques.
    Additionally, the example should demonstrate an advanced obfuscation technique with a complex code sample to avoid simple obfuscation methods that are easily reversible.
  agent: "researcher_agent"

deobfuscate_code:
  description: "Attempt to revert obfuscation and restore clarity to code." # todo: unuse it 
  expected_output: "Readable code resembling the original version."
  agent: "deobfuscation_agent"

verify_correctness:
  description: "Compare functional output of original and deobfuscated versions." # todo: adjust it so that if input arguments are requried, you should try all the possibilities to check if the outpout is the same.
  expected_output: "Validation of correctness and confirmation of preserved behavior."
  agent: "verifier_agent"
